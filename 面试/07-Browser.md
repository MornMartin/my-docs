### 怎样获取静态资源
* 当目标URL为第一次请求时，直接向服务器请求资源，并根据`Cache-Control`策略决定是否缓存该资源，以及过期时间等。
* 当目标URL不为第一次请求时，查询本地缓存，获取有效的目标资源。否则向服务器发起请求。

### 怎样渲染静态资源
1. 解析HTM生成文档树：包含所有节点。
2. 解析style标签、通过link请求的CSS文件生成样式规则。
3. 结合文档树和样式规则生成渲染树：仅包含可视化节点，如`display:none`以及head、link、script等标签不在此列。
4. 布局：根据渲染树计算每个节点信息。
5. 渲染视图。
* 若解析文档过程中遇到script标签，默认会停下来优先去解析脚本（因为可能包含DOM操作）

### 什么是强制缓存与协商缓存
* 强制缓存：根据响应头`Cache-Control`或`Expires`规则进行缓存的资源，在有效期内再次请求时都从缓存里直接获取。
* 协商缓存：当缓存资源过期或无法判断缓存资源是否有效时，利用`etag`、`Last-Modified`等信息与服务端确认资源的有效性，若仍有效时返回304，否则返回200

### 怎样设置Cache-Control
* max-age=\<seconds\>：设置缓存存储的最大周期，时间是相对于请求的时间，`Expires`是绝对时间。
* no-cache：不是不缓存，而是在使用缓存的资源之前，强制要求将资源信息提交给服务器进行校验
* no-store：不使用任何缓存。
* public：可以被客户端、代理服务器等缓存。
* private：只能被客户端缓存。

### GET和POST区别
`PUT/DELETE与POST类似`
* 语义上：一般约定GET是获取，POST是发送；但当查询条件过多，URL长度超过浏览器限制时，也有使用POST的Body携带查询参数请求数据的情况。
* 参数携带：GET仅可使用URL携带参数；POST可以使用URL以及Body携带参数，但通常不会使用Query。

### 什么是跨域
* 定义：Ajax请求的目标服务与文档部署服务的域名、端口或协议的任何不一致就会触发浏览器的同源策略；若Ajax请求的响应头没有包含对当前文档部署服务跨域获取资源的允许，则无法正确获取响应信息。
* 意义：不同源的站点cookie不可共享，WEB服务通常以cookie作为会话依据，被恶意利用会导致数据泄露；
* 规避：
    * 设置CORS头：`Access-Control-Allow-Origin`的值包含文档部署服务的域名或配置成`*`（对所有WEB服务开放跨站资源请求）。
    * jsonp：定义全局函数，并请求一段js脚本包含对该全局函数的调用，数据通过函数调用的入参传递。
    * 代理：使用Nginx等配置文档部署服务的正向代理。

### 什么是跨站脚本攻击
* 定义：跨站脚本攻击(Cross Site Script, 简称为XSS),往WEB页面（可以是innerHTML、标签属性值等）插入可执行语句或脚本；当用户浏览到问题页面时，脚本执行即触发攻击逻辑。可能利用当前会话盗取用户信息以及进行一些敏感操作等。
* 预防：
    1. 从源头上，对用户输入进行校验
    2. 从客户端，对外部输入要进行适当的编码
    3. 从服务端，设置`Content-Security-Policy`响应头，对项目中引入的三方脚本保持谨慎。

### 什么是websocket
* 定义：为浏览器设计基于TCP的全双工通信协议，协议标识符使用ws或wss类似于http和https
* 使用：创建Websocket实例，连接成功后，发送消息使用`send`方法，接收消息通过监听`onmessage`事件
* 连接：客户端收首先发送标准HTTP协议，携带`Upgrade:websocket`等请求头，表示需要升级协议以及指定版本，客户端响应101表示确认并已切换协议。
* 意义：相较于轮询，减少无意义消息发送；相较于长连接/长轮询需要分配一个线程hold请求，websocket不需要还方便做负载均衡

### 什么是localStorage与sessionStorage
* 定义：都是当前页面下用于临时存储数据的对象。
* 区别：sessionStorage在浏览器页签关闭时，对应数据会被清空，而localStorage不会
* 使用：`getItem`、`setItem`、`removeItem`和`clear`

### 什么是cookie
* 定义：HTTP协议是无状态的，即没有历史信息的支持。通过用户在访问网站后留下的一个信息片段，来记录用户操作以及授权等信息。每次请求时，通过`Cookie`请求头携带该信息。
* 设置：
    * 客户端：通过对`document.cookie`以`key=value`格式进行赋值，若key不存在为添加；当key存在且domain和path与赋值目标值一致则为覆盖；通过覆盖已存在key的过期时间为此前时间即可删除该key
    * 服务端：通过响应`Set-Cookie`，其内容将被设置成cookie
