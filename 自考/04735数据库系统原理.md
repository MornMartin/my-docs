# 数据库系统原理
## 1 数据库系统概述
### 1.1 数据库系统基本概念
数据： 描述事实的符号记录。包括数字、字母、文字等。

<b id="database-system">数据库</b>： 计算机中长期存储，有组织的，可共享的大量数据集合。

数据库管理系统：位于用户与操作系统之间的一层数据库管理软件。功能包含
* 数据定义功能，定义数据库中的数据对象，建表。
* 数据控制功能，数据的增删改查。
* 数据库的运行管理，保证数据的安全性、完整性、多用户队数据库的并发使用以及故障后的系统恢复。
* 数据库的建立和维护功能，包括空间维护、备份与恢复、重组织、性能监视、分析等。
* 数据组织、存储和管理功能。
* 其他功能，如与其他软件的网络通信功能。

数据库系统：指在计算机中引入数据库技术之后的系统，包括数据库、数据库管理系统及相关实用工具、应用程序、数据库管理员和用户。
### 1.2 数据管理技术的发展
`数据管理技术共经历了人工管理、文件系统和数据库系统三个阶段。`

 人工管理阶段：所涉及的数据处理工作基本都是靠手工方式来进行，硬件方面的数据只能放在纸带或者卡片上。***记录内无结构，整体无结构。***
   * 数据不保存
   * 没有应用程序管理数据
   * 数据面向应用

 文件系统阶段：将数据的逻辑结构和物理结构分离，由“存放方法”实现逻辑结构与物理结构之间的映射。***记录内有结构，整体无结构。***
   * 数据可长期存储。
   * 不能实现数据的普通共享，只能实现文件级的共享。

**数据库系统阶段**： [数据库](#database-system)包含以下特点
   * 数据集成
   * 数据共享性高
   * 数据冗余小：不用重复存储，避免漏更新，保证数据一致性。
   * 数据一致性好
   * 数据独立性高
   * 实施统一管理与控制
   * 减少应用程序开发与维护的工作量
### 1.3 数据库系统的结构

**三级模式结构**：用户级、概念级和物理级
   * 外模式：也称为子模式或用户模式，是数据库用户（包括程序员和最终用户）能够看见和使用的局部数据的逻辑结构和特征描述。
   * 模式：也称为概念模式或逻辑模式，是数据库中全体数据的逻辑结构和特征描述。
   * 内模式：也称为存储模式，是对数据库中数据物理结构和存储方式的描述。设计围绕提高数据库性能和有效存储空间。

数据独立性：指使用数据的应用程序和数据库的数据之间相互独立，不受影响。即数据或应用程序的修改不会引起另一方的修改。

外模式-模式映像：定义了各个外模式与模式之间的映像关系，指出映像双方是如何进行转换的。保证了逻辑独立性。

模式-内模式映像：定义了数据库全局逻辑结构与物理存储之间的对应关系。保证了物理独立性。

外部体系结构：集中式结构、分布式结构和并行结构。

运行与应用结构：
   * 客户/服务器结构（C/S）：使用命令行客户端、图形化界面管理工具、应用程序等来连接数据库管理系统。
   * 浏览器/服务器结构（B/S）：也称三层客户/服务器结构，将与数据库系统交互的客户端进一步细分为“表示层”和“处理层”。其中，“表示层”是数据库使用者操作和展示界面，通常为浏览器。而“处理层”则主要负责数据库使用者的具体应用逻辑，与后台的数据库管理系统组成功能更加丰富的“胖服务器”。

### 1.4 数据模型
`描述数据的结构、定义数据的操作以及对数据间的约束。`

**数据结构**： 描述系统的**静态特性**，即数据对象的类型、内容及数据对象之间的联系。

**数据操作**：描述系统的**动态特性**， 是数据对象的实例允许执行操作的集合及有关的操作规则。

**数据约束**： 描述数据结构中数据间的语法、语义关联，包括相互制约规则。保证数据的正确性、有效性与相容性。

实体：客观存在并可相互区别的事物。

实体型：用实体名、属性名集合来抽象刻画同类实体，称为实体型。

实体集：同型实体的集合，称为实体集。

联系： 实体内部以及事物之间的联系。实体内部之间的联系，各属性之间的联系；实体之间的联系，一对多、一对一、多对多。

数据概念模型：描述现实世界的事物，与具体的计算机系统无关。通常用E-R图（E-R模型）来表示。实体用矩形框，联系用菱形框，属性用椭圆框。

数据逻辑模型：描述数据整体逻辑结构，是数据抽象的中间层。**包括层次模型、网状模型、关系模型、面向对象模型等**。

数据物理模型：描述数据在存储介质上的组织结构，是逻辑模型的物理实现。

## 2 关系数据库
### 2.1 关系数据库概述

**基本特征**：使用关系数据模型组织数据。

常见系统：FoxPro、Access以及MySQL。

### 2.2 关系数据模型
`关系模型包含三个组成要素，分别是关系数据结构、关系操作集合和关系完整性约束。`
#### 2.2.1 关系数据结构

名词释义：
   * 表（关系）：一个关系对应一张基本二维表，一个或多个基本表对应一个文件。每个关系名称唯一。有基本关系、查询表和视图表三种。
   * 列（属性/字段）：表示实体的一个属性，有相同的数据类型。表中每列名称唯一。
   * 元（度）：属性的个数。
   * 行（元祖/记录）：表中的数据是按行存储的，每行有若干字段值组成，每个字段值描述该对象的一个属性或特征。
   * 分量：元祖中的一个属性值。
   * 码（键/key）：如果存在一个关系中，存在这样的属性（或属性组），使得该关系的任何两个元祖，在该属性（或属性组）上值的组合都不相同，即这些属性（或属性组）的值能用来唯一标识该关系的元祖，则称为属性（或属性组）为该关系的码或键；
   * 超码（超键）：如果在关系的一个码或键中移去某个属性，它仍然是这个关系的码，则称这样的码或键为该关系的超码或超键。
   * 候选码（候选键）：如果在关系的一个码或键中，不能移去某个属性，否则它就不是这个关系的码或键，则称为这样的码或键为该关系的候选码或候选键。
   * 主码（主键）：在一个关系的若干个候选码或候选键中，指定一个用来唯一标识关系的元祖，则称这个被指定的候选码或候选键为该关系的主码或主键。
   * 全码（全键）：在一个关系中，任何一个码或键皆可以用来唯一标识关系的元祖，则这样的主码或主键称为全码。
   * 主属性和非主属性：关系中包含在任何一个候选码中的属性称为主属性，不包含在候选码中的属性称为非主属性。
   * **外码（外键）**：当关系中的某个属性（或属性组）不是这个关系的主码或候选码，而是另一个关系的主码是，称该属性（或属性组）为这个关系的外码或外键。
   * 参照关系和被参照关系：指以外码相关联的两个关系，以外码为主码的关系称为被参照关系，外码所在的关系称为参照关系。
   * 域：属性的取值范围。
   * 数据类型：表示每个列中都有相应的数据类型，用于限制该列中存储的数据。
   * 关系模式：同数据模型一样，数据库也有“型”和“值”之分。在关系数据库中，关系模式是型，关系是值，即关系模式是对关系的描述。

      `表名（属性1， 属性2，...）`
   * 关系数据库：关系数据库是以采用关系作为数据组织方式的一类数据库，其数据库操作建立在关系代数的基础上。

**关系数据库对关系的具体要求**：
   * 每一个属性都是不可分解的。
   * 每一个关系仅仅有一种关系模式，即每一种关系模式中的属性的数据类型以及属性的个数是相对固定的。
   * 每一个关系模式中的属性必须命名，在同一个关系中，属性名必须是不同的。
   * 同一个关系中不允许出现候选码或候选键，值完全相同的元祖。
   * 在关系中元祖的顺序是无关紧要的，可以任意交换。
   * 在关系中属性的顺序是无关紧要的，可以任意交换。
#### 2.2.2 关系操作集合

基本关系操作：
   * **查询**：选择、投影、连接、除、并、交、差、笛卡尔积
   * 数据更新：插入、删除、修改

关系操作特点：集合操作方式，即操作的对象和结果都是集合。

关系数据语言分类：`SQL 兼具关系代数语言与逻辑演算语言`
   * 代数方式：主要有关系代数，他是通过对关系的操作来表达查询要求的方式。
   * 逻辑方式：主要有关系演算，他是用谓词来表达查询要求的方式。
   
关系代数：以集合代数为基础发展起来的，是关系操作语言的一种传统表示方式。操作三要素：操作对象、操作符、操作结果。其中，操作对象和操作结果均为关系（集合）；
   * 传统的集合运算：并集、差集、交集、笛卡尔积。
   * 专门的关系运算：
      * 选择：从指定关系中选取满足给定条件的若干元祖组成一个新的关系。

         `SELECT 关系名 WHERE 条件`
      * 投影：从指定关系中选取指定若干属性值组成一个新的关系。

         `PROJECTION 关系名(属性名1, 属性名2, ...)`
      * 连接：选取两个指定关系中的属性满足给定条件的元祖连接在一起组成一个新的关系。

         `JOIN 关系名1 AND 关系名2 WHERE 条件`
      * 除：若被除关系为R，除关系为S，则运算结果为一个R-S元关系。在进行除运算时，先将被除关系中的R-S列按值的不同分成若干组，然后检查每个组，看R-S列以外的那些列中是否包含除关系的全部元祖，包含则取该R-S列的值为商关系的一个元祖，否责不取。
#### 2.2.3 关系的完整性约束

完整性：数据库中数据与现实世界中应用需求的数据或数据库内数据之间的正确性、相容性和一致性。

完整性约束：数据完整性由完整性规则来定义，关系模型的完整性规则是对关系的某种约束。
   1. 实体完整性约束：关系的主码组成不能为空，且实体具有唯一性标识。
   2. 参照完整性约束：关系中不允许引用不存在的实体。
   3. 用户定义完整性约束：针对某一应用环境的完整性约束条件。

完整性约束的校验：
   1. 执行插入操作：
      * 首先检查实体完整性，即检查主码属性值是否存在？或者是否为空？
      * 再检查参照完整性，向参照关系加入时，检查外码属性上的值是否在被参照关系的主码属性值中存在？
      * 最后检查用户定义完整性，检查要被插入的元祖中各属性值是否满足域完整性约束和其他特殊定义的完整性规则。
   2. 执行删除操作：一般只需要对被参照关系检查参照完整性约束。
   3. 执行更新操作：更新操作可以看成是先执行删除操作，再执行插入操作。

### 2.3 关系数据库的规范化理论
`关系数据库的规范化理论是关系数据库设计的理论依据。`
#### 2.3.1 关系模式中可能存在的冗余和异常问题
`从设计的角度来看，关系模式有“好”与“不好”之分。“不好”的关系模式可能存在如下问题。`
1. 数据冗余： 指同一数据被反复存储的情况。
2. 更新异常：数据冗余将导致存储空间浪费和潜在数据不一致性及修改麻烦等问题。
3. 插入异常：指应该插入到数据库中的数据不能执行插入操作的情况。如，一个关系包含学生信息，也包括选课信息及授课教师信息，若需要单独插入授课教师信息的情况。
4. 删除异常：指不应该删去的数据被删去的情况。
#### 2.3.2 函数依赖与关键字

关键字：即码或键；

**函数依赖**：关系中属性间的对应关系。在关系中，若属性X的每一个值，都有属性Y的唯一值与之对应，则称X决定Y或属性Y依赖于属性X（X -> Y）;
   1. 完全函数依赖：X、Y为属性集，且X -> Y; 对于X的任何真子集X', 有
   X' -> Y 不成立，则称Y完全函数依赖于X。
   2. 部分函数依赖：X、Y为属性集，且X -> Y; 对于X存在一个真子集X',有X' -> Y 成立，则称Y部分函数依赖于X。
   3. 传递函数依赖：X、Y、Z为属性集，X -> Y 、Y -/> X、Y-> Z，有 X -> Z, 则Z传递函数依赖于X。

#### 2.3.3 范式与关系规范化过程
`关系数据库中的关系需要满足一定的要求，不同程度的要求称为内不同的范式（NF）。`

1. 第一范式(1NF)：关系每列与行的交点处取值不可再分，即不含重复组，不存在嵌套结构。
2. 第二范式(2NF)：关系满足1NF，且所有非主属性完全函数依赖于候选关键字。
3. 第三范式(3NF)：关系满足2NF，且所有非主属性都不传递函数依赖于候选关键字。
4. BCNF: 关系满足3NF，X、Y为其属性集，F为其函数依赖集; 有F中所有函数依赖X -> Y(Y不属于X)中的X必包含候选关键字，则该关系为BCNF。

   `BCNF解决了3NF中出现的插入及删除操作异常等问题`
#### 2.3.4 关系规范化理论的应用
`关系规范化理论主要应用于数据库设计中的概念设计阶段，对所产生的概念设计，可用它来分析其实体划分是否合适，判断属性分配到哪个实体中更为合理。`
## 3 数据库设计
### 3.1 数据库设计概述
`数据库设计使将数据库系统与现实世界进行密切地、有机地、协调一致的结合过程。`

数据库生命周期：
   * 数据库分析与设计阶段：包括需求分析、概念设计、逻辑设计和物理设计。
   * 数据库实现与操作阶段：包括数据库的实现、操作与监督、修改与调整三个子阶段。

数据库设计的目标：
   * 满足应用功能需求：主要指用户当前与可预知的将来应用所需的数据及其联系，应全部准确地存储在数据库之中，从而满足用户应用对数据增、删、改、查的需求。
   * 良好的数据库性能：主要指用户对数据的高效率存取和空间的节省，并具有良好的数据共享性、完整性、一致性及安全保密性。

数据库设计的内容：从用户对数据的需求出发，研究并构造数据库的过程
   * 结构设计：包括概念设计、逻辑设计和物理设计
   * 行为设计：确定数据库用户的行为和动作，是动态的，因为用户的行为会使数据库的内容发生变化

数据库设计的方法：
   * 直观设计法：利用设计者的经验和技巧来设计
   * 规范设计法：
      1. 新奥尔良设计方法
      2. 基于E-R模型的数据库设计方法
      3. 基于第三范式的设计方法
   * 计算机辅助设计法：利用辅助软件，以人机交互的方式完成数据库设计的某些过程

数据库设计的过程：
   1. 需求分析阶段
   2. 结构设计与行为设计阶段
   3. 数据库实施阶段：加载和调试运行应用程序
   4. 数据库运行于维护阶段。

### 3.2 数据库设计的基本步骤
`分段设计方法已在数据库设计中得到广泛的应用，遵循自顶向下、逐步求精的原则。`
需求分析：
   1. 确定数据库范围：确定数据库应支持那些应用功能。
   2. 应用过程分析：分析每一部门或应用需要用到哪些数据、数据的使用顺序、对数据作何处理、处理策略以及处理的结果。
   3. 收集与分析数据
      1. 静态结构：不施加应用操作于其上时数据的原始状况
      2. 动态结构：应用施加于数据之上之后的数据情况
      3. 数据约束：数据的安全保密性、完整性、响应时间和数据恢复
   4. 编写需求分析报告：
      1. 数据库的应用功能目标：数据库的应用范围
      2. 标明不同用户视图范围：不同部门或功能的局部视图范围
      3. 应用处理过程需求说明：数据流程图、任务分类表、数据操作特征表以及操作过程说明书。
      4. 数据字典：各类数据详细描述的集合
      5. 数据量：数据总量
      6. 数据约束

概念结构设计：在需求分析报告的基础上，设计满足应用需求的概念模型。常用设计方法有**实体分析（自顶向下）法和属性综合（自底向上）法**，其步骤：
   1. 建立局部信息结构
   2. 将局部信息结构合成为全局信息结构并优化

逻辑结构设计：
   1. 输入信息：概念模型；有关响应时间、安全保密性、数据完整性的说明；数据量及使用频率
   2. 输出信息：概念模式；一个或多个外部视图；物理设计说明；程序设计说明
   3. 设计步骤：
      1. 模型转换：将概念模型转换为等价的DBMS所支持的数据模型结构。
      2. 子模式设计：抽取或导出模式的子集
      3. 编制应用程序设计说明：为应用程序设计提供依据和指导
      4. 设计评价：分析并验证模式及子模式合理性与正确性，其方法是*通过程序设计指南中提交的程序执行逻辑模拟执行来考核模式与子模式是否满足应用需求，如无遗漏并进一步估计数据容量与存取效率，为物理设计提供参考，若发现不合理之处，则返回到模型转换处重新执行，直到满足要求为止*

物理设计：对于给定的数据库逻辑结构，研究并构造物理结构的过程，其具体任务主要是**确定数据库在存储设备上的存储结构以及存取方法**

数据库实施：根据数据库逻辑结构和物理设计，在实际的计算机系统中建立数据库并试运行。
   1. 加载数据：将符合要求的初始数据装载到数据库中去
   2. 应用程序设计：编写数据的增删改查
   3. 数据库试运行：对数据库进行各种操作，检验其功能和性能

数据库运维：经过试用测试后，投入生产环境中运行。做好维护工作、发现和分析问题；对数据进行转储，对系统故障进行恢复处理等。最难的是数据库重组与重构。
### 3.3 关系数据库设计方法

概念结构设计方法：
   1. E-R图的表示方法：将实体、实体的属性和实体间的联系转换为某种关系模式。
      * 关系：1对1，1对多，多对多
   2. 局部信息结构设计：根据需求分析报告中标明不同用户视图范围以建立满足该范围内用户需求的信息结构。
      1. 确定局部范围
      2. 选择实体：最大的困难是区别实体与属性
      3. 选择实体的关键字属性
      4. 确定实体间联系
      5. 确定实体的属性
   3. 全局信息结构设计：将所有局部信息结构合并成为一个全局信息结构。合并过程是一个不断发现和解决冲突的过程。
      1. 属性冲突：属性域冲突（属性值的类型、取值范围不同）和属性值单位冲突
      2. 命名冲突：同名异义和异名同义
      3. 结构冲突：同一对象在一个局部E-R图里作为实体，在另一个局部E-R图里作为属性、同一个实体在不同的E-R图里属性个数和类型不同以及实体之间的联系在不同E-R图里是不同的类型

逻辑结构设计方法：
   1. E-R图向关系模型的转换：将实体、实体的属性和实体间的联系转换为某种关系模式。遵循以下原则：
      1. 一个实体型转换为一个关系模式
      2. 一对一联系可以转换为一个独立的关系模式或与任意一端对应关系模式合并
      3. 一对多联系可以转换为一个独立的关系模式或与N端对应的关系模式合并
      4. 多对多联系可以转换为一个关系模式，与该联系相连的各实体的码以及联系本身属性均转换为关系的属性，而关系的码为各实体码的组合。
      5. 具有相同吗的关系可以合并
   2. 数据模型的优化：以关系规范化理论为指导
      1. 确定各属性间的函数依赖关系
      2. 对于各个关系模式之间的数据依赖进行极小化处理，消除冗余的联系
      3. 判断每个关系模式的范式，根据实际需要确定合适的范式
      4. 对关系模式进行必要的分解，提高数据操作的效率和存储空间的利用率
   3. 设计用户子模式：在不改变原有表结构的情况下，再抽象出一张表。

物理设计方法：
   1. 建立索引：一个单独的数据库结构，是表中一列或若干列值的集合和相应的指向表中物理标识这些数据的逻辑指针清单。一般建立索引的数据对象需要被较少操作，用以建立索引的属性也是使用频率较高的属性。
   2. 建立聚集：指将相关的数据尽可能存放于一个物理块中。
   
## 4 SQL与关系数据库基本操作
### 4.1 SQL概述
`结构化查询语言（Structured Query Language），是一种介于关系代数和关系演算之间的语言。`

发展：由于具有语言简洁、方便实用、功能齐全等优点，最终发展成为关系数据库的标准语言，用户可以用几乎相同的语句在不同数据库系统上执行同样的操作。

特点：不区分大小写
   1. SQL不是某个特定数据库供应商专有的语言，几乎所有关系数据库管理系统都支持SQL
   2. SQL简单易学，它的语句全是具有很强的描述性英语单词所组成
   3. SQL看上去简单，但它实际上是一种强有力语言，灵活使用，可以进行非常复杂和高级数据库操作

组成：
   1. 数据定义语言(DDL)：主要用于对数据库及数据库中的各种对象进行创建、删除、修改等操作，如CREATE、ALTER、DROP
   2. 数据操纵语言(DML)：主要用于操作数据库中各种对象，特别时检索和修改数据，如SELECT、INSERT、UPDATE、DELETE
   3. 数据控制语言(DCL)：主要用于安全管理，对用户进行授权或权限回收，如GRANT、REVOKE
   4. 嵌入式和动态SQL规则：规定了SQL在高级程序设计语言中使用的规则和方法
   5. SQL调用和会话规则

### 4.2 MySQL预备知识

MySQL：是一个关系数据库管理系统（RDBMS）
   1. 体积小
   2. 速度快
   3. 开放源代码
   4. 遵循GPL(GUN)通用公共许可

架构方式：
   1. LAMP：Linux+Apache+MySQL+PHP/Perl/Python
   2. WAMP：Windows+Apache+MySQL+PHP/Perl/Python

SQL语言组成要素：
   1. 常量：程序运行过程中值不变的量，也称为字面值或标量值。
      1. 字符串常量：字符串是指用单引号或双引号括起来的字符序列，分为ASCII字符串常量和Unicode字符串常量。
      2. 数值常量：分为整数常量和浮点数常量，都用十进制表示。
      3. 十六进制常量：一个十六进制值通常指定为一个字符串常量。
      4. 日期常量：用单引号将表示日期时间的字符串括起来构成。
      5. 位字段值：可以使用b'value格式符号书写位字段值，其中，value是一个用0或1书写的二进制值，位字段符号指定分配给BIT列的值。
      6. 布尔值：只有两个可能的值，TRUE或者FALSE，用1或0表示。
      7. NULL：适用于各种列类型，用来表示空值、无数据等意义。
   2. 变量：用于临时存储数据，变量中的数据可以随程序的运行而变化。
      1. 系统变量：以"@@"作为前缀
      2. 用户变量：以"@"作为前缀
   3. 运算符：提供编程语言中常见的运算符
      1. <span id="comparisonOperators">算术运算符</span>：+、-、*、/、%
      2. 比较运算符：=、>、<、>=、<=、<>或!=（不等于）、<=>（相等或都等于空）
      3. 位运算符：&（位与）、|（位或）、^（异位或）、~（位取反）、<<（位左移）、>>（位右移）
      4. <span id="logicalCalculus">逻辑运算符</span>：NOT或!（逻辑非）、AND或&&（逻辑与）、OR或||（逻辑或）、XOR（逻辑异或）
   4. 表达式：是常量、变量、列名、复杂计算、运算符和函数的组合，一个表达式通常可以得到一个值。
   5. 内置函数：可以直接调用的系统提供的函数，用于对数据库表进行相关操作。
      1. 数学函数，如ABS()、SORT()
      2. <span id="aggregateFunction">聚合函数</span>，如COUNT()、MAX()、MIN()、SUM()、AVG()
      3. 字符串函数，如ASCII()、CHAR()
      4. 日期时间函数，如NOW()、YEAR()
      5. 加密函数，如ENCODE()、ENCRYPT()
      6. 控制流程函数，如IF()、IFNULL()
      7. 格式化函数，如FORMAT()
      8. 类型转换函数，如CAST()
      9. 系统信息函数，如USER()、VERSION()

### 4.3 数据定义

数据库模式定义：包含数据库的创建、选择、查看、删除、修改等操作

语法说明：
   * {}：必填项
   * []：可选项
   * 结束：执行语句需以";"结尾，方可被执行

创建数据库：
   * 创建： CREATE{DATABASE|SCHEMA} [IF NOT EXISTS] db_name
   * 指定字符集：[DEFAULT] CHARACTER SET [=] charset_name
   * 指定字符集校对规则：[DEFAULT] COLLATE [=] collation_name

选择数据库：USE db_name

修改数据库：
   * 修改： ALTER {DATABASE|SCHEMA} [db_name]
   * 修改字符集：[DEFAULT] CHARACTER SET [=] charset_name
   * ...

删除数据库：DROP {DATABASE|SCHEMA} [IF EXISTS] db_name

查看数据库：SHOW [DATABASES|SCHEMAS] [LIKE pattern|WHERE expr]

创建表：CREATE TABLE [IF NOT EXISTS] tbl_name(
   字段名1 数据类型 [列级完整性约束条件] [默认值]
   [, 字段名2 数据类型 [列级完整性约束条件] [默认值]]
   [, ...]
   [表级完整性约束]
)[ENGINE=引擎类型]

更新表：ALTER TABLE tb_name
   * 添加列：ADD 属性名 数据类型
   * 修改列：CHANGE 旧属性名 新属性名 数据类型
   * 修改列：ALTER 属性名 {SET DEFAULT 默认值|DROP DEFAULT}
   * 修改列：MODIFY 属性名 数据类型
   * 删除列：DROP 属性名

重命名表：RENAME TABLE tbl_name TO new_tbl_name [, tbl_name_2 TO new_tbl_name_2]

删除表：DROP [TEMPORARY] TABLE [IF EXISTS] tbl_name [, tbl_name_2] [RESTRICT|CASCADE]

查看表：
   * 显示表名称：SHOW [FULL] TABLES [{FROM|IN} db_name] [LIKE pattern|WHERE expr]
   * 显示表结构：SHOW [FULL] COLUMN [{FROM|IN} tbl_name] [LIKE pattern|WHERE expr]

*索引：DBMS根据表中的一列或若干列按照一定顺序建立的列值与记录行之间的对应关系表，可以有多个
   * 用途划分：
      1. 普通索引（INDEX）
      2. 唯一性索引（UNIQUE）
      3. 主键索引（PRIMARY KEY）
      4. 全文索引（FULLTEXT）
      5. 聚簇索引
   * 弊端：
      1. 索引是以文件形式存储，会占用磁盘空间
      2. 索引在提高查询速度的同时，却会降低更新表的速度。在更新表中索引列上的数据时，也需要同步更新到索引

创建索引：CREATE [UNIQUE] INDEX index_name ON tbl_name(col_name[(length)][ASC|DESC], ...)

查看索引：SHOW {INDEX|INDEXES|KEYS} {FROM|IN} tbl_name [{FROM|IN} db_name] [WHERE expr]

删除索引：DROP INDEX index_name ON tbl_name

### 4.4 数据更新

插入数据：
   * 创建：INSERT INTO tbl_name(column_list) VALUES(value_list1)
   * 拷贝：INSERT INTO tbl_name(column_list) SELECT (column_list2) FROM tbl_name2 [WHERE expr]
   * 按列：INSERT INTO tbl_name SET col_name={expr|DEFAULT} ,...

删除数据：DELETE FROM tbl_name [WHERE expr]

清空数据：TRUNCATE TABLE tbl_name
> 整个表先删除，再按格式重建，效率更高，无法恢复。

修改数据：UPDATE tbl_name SET col_name=expr [, col_name2=expr ,...] [WHERE expr]

### 4.5 数据查询

<span id="queyrProgram">基本语法</span>：
>```
>SELECT [ALL|DISTINCT|DISTINCTROW] select_expr [, select_expr2...]
>FROM tbl_reference
>[WHERE where_expr]
>[GROUP BY {col_name|grp_by_expr|position} [ASC|DESC], ... [WITH ROLLUP]]
>[HAVING where_expr]
>[ORDER BY {col_name|order_by_expr|position} [ASC|DESC], ...]
>LIMIT {limit OFFSET offset}
>```

* SELECT：用于指定输出的字段
* FROM：用于指定数据来源
* WHERE：用于指定数据选择条件
* GROUP BY：用于对检索到的记录进行分组
* HAVING：用于指定组的选择条件
* ORDER BY：用于对查询结果进行排序
* LIMIT ... OFFSET：用于对查询结果进行截取

指定字段：SELECT
   * 所有列：*
   * 指定列：column_name [,column_name2 ...]
   * 别名：column_name AS column_alias [, column_name2 AS column_alias2 ...]
   * 数据替换：
      >```
      >CASE
      >WHEN condition1 THEN expr1
      >WHEN condition2 THEN expr2
      >ELSE default
      >END [AS] column_alias
      >```
   * 数据计算：col_name{+|-|*|/ ...}col_name2 as column_alias
   * [聚合函数](#aggregateFunction)：{AVG|SUM|COUNT|MAX ...}(col_name) as column_alias
   
指定数据来源：FROM
   * 指定表：tbl_name [, tbl_name2 ...]
   * 表连接：
      * 交叉连接：tbl_name1 CROSS JOIN tbl_name2
      * **内连接**：tbl_name1 [INNER] JOIN tbl_name2 ON expr
      * 等值连接：tbl_name1, tbl_name2 WHERE tbl_name1.col_name = tbl_name2.col_name
      * 左连接：tbl_name [LEFT] JOIN tbl_name2 ON expr
      * 右链接：tbl_name [RIGHT] JOIN tbl_name2 ON expr

指定筛选条件：WHERE
   * [比较运算](#comparisonOperators)：比较两个表达式的值
   * [逻辑运算](#logicalCalculus)
   * 判定范围：expr [NOT] BETWEEN expr2 AND expr3
   * 判断空值：IS [NOT] NULL
   * 判断集合：[NOT] IN

子查询：
   * 表子查询：返回一个表
   * 行子查询：返回带有一个或多个值的一行数据
   * 列子查询：返回一列数据，每行只有一个值
   * 标量子查询：返回仅仅一个值

### 4.6 视图
`视图是一个或多个表导出的（虚）表，视图是提供数据库用户以多角度观察数据库中数据的一种重要机制`

视图与基本表的区别：
   1. 视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立
   在数据库中对真实表的查询基础上的
   2. 视图的内容是由存储在数据库中进行查询操作的SQL语句来定义的，它的列数据与行数据均来自于定义视图的查询所引用的真实表，并且这些数据是在引用视图时动态生成的
   3. 视图不是以数据集的形式存储在数据库中，它所对应的数据实际上是存储在视图所引用的基本表中
   4. 视图是用来查看存储在别处的数据的一种虚拟表，其自身并不存储数据

使用视图的优点：
   1. 集中分散的数据
   2. 简化查询的语句
   3. 重用SQL语句
   4. 保护数据安全
   5. 共享所需数据
   6. 更改数据格式

创建视图：CREATE [OR REPLACE] VIEW view_name [(col_list)] AS [查询语句](#queyrProgram)

删除视图：DROP VIEW [IF EXISTS] view_name [, view_name2 ...]

修改视图定义：ALTER VIEW view_name AS [查询语句](#queyrProgram)

查看视图定义：SHOW CREATE VIEW view_name

更新视图数据：对于可更新的视图，需要该视图中的行和基本表中的行具有一对一的关系。使用INSERT、UPDATE、DELETE语句

查询视图数据：如同查询数据库中真实表一样，对视图进行数据查询检索，主要体现在一下应用中：
   1. 利用视图简化复杂的表连接
   2. 使用视图重新格式化检索出的数据
   3. 使用视图过滤出不想要的数据

## 5 数据库编程
### 5.1 存储过程
`一组为了完成某项特定功能的SQL语句集合，其实质上就是一段存储在数据库中的代码，它可以由声明式的SQL语句（如CREATE、UPDATE和SELECT等语句）和过程是SQL语句（如IF...THEN...ELSE控制结构语句）组成。`

存储过程优点：
1. 可增强SQL语言的功能和灵活性
2. 良好的封装性
3. 高性能
4. 可减少网络流量
5. 存储过程可作为一种安全机制来确保数据库的安全性和数据的完整性。

创建存储过程：CERATE PROCEDURE sp_name([proc_param [, ...]])
> 存储过程体可能包含有多条SQL语句，这些SQL语句如果仍以分号结尾，那么SQL服务器可能在遇到第一条语句结尾处的分号作为整个程序的结束。通常需要使用`DELIMITER 自定义结束符号`命令将结束标志临时修改为其他符号。

<b id="define-procedure">定义存储过程</b>：DELIMITER {结束符号} BEGIN...END {结束符}
* 定义局部变量：DECLARE var_name [,...] type [DEFAULT value]
* 通过表达式赋值局部变量：SET var_name=expr[, var_name2=expr2 ...]
* 通过选定列赋值局部变量：SELECT col_name[, ...] INTO var_name[, ...] FROM expr;
   > 只能返回一个结果，将列值和变量名值一一对应；
* 流程控制语句：
   * 条件判断语句：
      * IF condition THEN... [ELSE [IF condition2] THEN...] END IF
      * CASE [var_name] WHEN {value|expr} THEN...  [WHEN {value|expr} THEN...] END CASE
   * 循环语句：
      * WHILE condition DO... END WHILE
      * REPEAT... UNTIL condition END REPEAT
      * LOOP... LEAVE condition END LOOP
* 游标：解决SELECT...INTO语句只能处理单条数据的问题，可存储多行数据。
   1. 创建游标：DECLARE cursor_name CURSOR FOR SELECT...
   2. 打开游标：OPEN cursor_name
      > 游标存储的是对数据的引用，可多次打开，每次结果一定一致（可能被更新）。
   3. 读取游标：FETCH cursor_name INTO var_name[, var_name2...]
      > 每次执行依次读取一行，变量数据必须等于SELECT子句中列的数目。
   4. 关闭游标：CLOSE cursor_name

调用存储过程：CALL sp_name([param [, ...]])
   > 入参个数、类型需要和定义时使用到的参数个数、类型一致

删除存储过程：DROP PROCEDURE [IF EXISTS] sp_name

查找存储过程：SHOW CREATE PROCEDURE

### 5.2 存储函数
`存储函数与存储过程一样，都是由SQL语句和过程式语句所组成的代码片段，并且可以被应用程序和其他SQL语句调用。`

与存储过程的区别：
   1. 存储函数不能拥有输出参数，而存储过程可以拥有输出参数
   2. 存储过程的调用需要使用CALL，而存储函数不用
   3. 存储函数必须包含一条RETURN语句，而存储过程不能使用RETURN语句。

创建存储函数：CREATE FUNCTION sp_name(param [, ...]) RETURN type

定义存储函数：同[定义存储过程](#define-procedure)

调用存储函数：SELECT sp_name(param, [, ...])

删除存储函数：DROP FUNCTION [IF EXISTS] sp_name

查看存储函数：SHOW FUNCTION

## 6 数据库安全与保护
### 6.1 数据库完整性
`指数据库中数据的正确性和相容性。`

作用对象：
   1. 列级约束：主要指对列的类型、格式、取值范围、精度以及是否可以为空值等的约束。
   2. 元祖约束：指元祖中各个字段之间的相互约束。如，某个活动的开始日期不能晚于结束日期。
   3. 表级约束：指若干元祖之间、关系之间的联系的约束。如，学生成绩表中学号要受学生信息表学号的约束。

定义完整性约束：关系模型的完整性规则是对关系的某种约束条件。
   1. 实体完整性：主要通过主键约束和候选键约束来实现。
      * 主键约束：每个表只能定义一个主键，且主键的值能够唯一标志表中的每一行记录；若是复合主键，不能包含不必要的列；使用PRIMARY KEY语句来实现，会自动产生PRIMARY KEY 索引。
      * 候选键约束：每个表可以有一个或多个候选键，候选键的值必须唯一；使用`UNIQUE`来定义，会自动产生UNIQUE索引。
   2. 参照完整性：通过在创建表或更新表的同时定义一个外键来声明来实现。
      1. 定义外键：FOREIGN KEY(foreign_key_name)
      2. 关联参照表：REFERENCES foreign_tbl_name(foreign_key_name)
      3. 设置同步关系：
         * 删除时：ON DELETE {RESTRICT|CASCADE}
            > 不可删除|删除同步
         * 更新是：ON UPDATE {RESTRICT|CASCADE}
            >不可更新|更新同步
   3. 自定义完整性：MySQL支持非空约束、CHECK约束和触发器三种用户自定义完整性约束。
      * 非空约束：NOT NULL
      * CHECK约束：CHECK (expr)

命名完整性约束：CONSTRAINT [symbol]
>完整性约束也可以执行修改、删除等操作，依赖于名字。基于表的完整性约束指定名字（列不可以），数据库中要唯一，没有明确给出时数据库会自动创建。

删除完整性约束：ALTER TABLE tbl_name DROP [{FOREIGN | PRIMARY} KEY] symbol

添加完整性约束：ALTER TABLE tbl_name ADD [CONSTRAINT [symbol]] {PRIMARY|FOREIGN|UNIQUE} KEY (col_name) {空|REFERENCES foreign_tbl_name(foreign_col_name)|空}

### 6.2 触发器
`用户定义在关系表上的一类由事件驱动的数据库对象，也是一种保证数据完整性的方法。`

创建触发器：CREATE TRIGGER trigger_name {BEFORE|AFTER} {INSERT|DELETE|UPDATE} ON tbl_name FOR EACH ROW trigger_body

删除触发器：DROP TRIGGER [IF EXISTS] [tbl_name] trigger_name

执行触发器：
   1. INSERT：可以使用NEW来访问被插入的行，允许修改，自增类型的值，BEFORE获取到的都是0，AFTER获取到的是自动更新的值。
   2. DELETE：可以使用OLD来访问被删除的行，不允许修改
   3. UPDATE：可以使用NEW来访问更新的值，使用OLD来访问以前的值；只有BEFORE时，NEW可以被更新，OLD为只读；

### 6.3 安全与访问控制

用户账号管理：每个数据库创建时会自动生成一个root账户，拥有数据库的所有权限，但一般仅用于进行用户管理。
1. 创建用户：CREATE USER user [IDENTIFIED BY [PASSWORD] password]
2. 删除用户：DROP USER user [, user2 ...]
3. 修改用户账户：RENAME USER old_user TO new_user [, old_ueser2 TO new_user2]
4. 修改用户口令：SET PASSWORD [FOR user] password

账户权限管理：新创建的账户不能执行任何操作，包括数据库的访问。
1. 授予权限：
   ```mysql
   GRANT 
      priv_type [(col_list)]
         [, priv_type [(col_list2)]...] 
      ON [object_type] priv_level
      TO user [IDENTIFIED BY [PASSWORD] password] [, user2 ...]
      [WITH GRANT OPTION]
   ```
   * priv_type：定义可执行的操作，如 SELECT|UPDATE|DELETE等
   * object_type：定义可操作的对象，如 TABLE|FUNCTION|PROCEDURE
   * priv_level： 指定数据库或表，"*"(当前数据库中所有表)、"."(所有数据库所有的表)、db_name、db_name.tbl_name等

2. 权限转移：
   ```mysql
   GRANT priv_type [(col_list)]
   ON [boject_type] priv_level
   TO user [, user2 ...]
   WITH GRANT OPTION
   ```
3. 权限收回：
   REVOKE priv_type[(col_list)]
   ON [object_type] priv_level
   FROM user [, user2 ...]

### 6.4 事务与并发控制

事务：用户定义的一个数据操作序列，这些操作可作为一个完整的工作单元，**要么全部执行，要么全不执行**。

事务的特征：数据库必须保证事务具有四个特征，即原子性、一致性、隔离性和持续性，也简称为事务的ACID特征。
   * 原子性：保证事务包含的一组更新操作是原子不可分的，即**事务是不可分割的最小工作单位**
   * 一致性：要求事务必须满足数据库的完整性约束，且执行完毕后将数据库由一个一致性状态转变到另一个一致性状态。
   * 隔离性：要求事务是彼此独立的、隔离的，即一个事务的执行不能被其他事务所干扰
   * 持续性：指一个事务一旦提交，他对数据库中数据的改变就应该是永久性的。

并发问题：事务是并发控制的基本单位，保证事务的ACID特征，需要DBMS对并发操作进行正确的调度。
* 丢失更新：存在两个事务，同时读入同一数据并加以修改，后提交的会对先提交事务造成破坏。
* 不可重复读：存在两个事务，T1读取数据后，T2执行更新操作，使T1无法再现前一次读取结果。
* 读“脏”数据：存在两个事务，T1修改某一数据，并写入磁盘；T2读取该数据后，T1事务回退；此时T2读取到的数据与数据库中的数据不一致，即不正确数据。

锁：允许或阻止一个事务对一个数据对象的存取特权，事务执行数据库操作时都要先请求相应的锁，即对读请求S锁，对更新（插入、删除、修改）请求S锁。
   * 排他锁（X锁）：若事务对数据加了X锁，所有别的事务对该数据的锁请求都必须等待事务释放锁（COMMIT或ROLLBACK）。
   * 共享锁（S锁）：若事务对数据加了S锁，别的事务还可以对该数据请求S锁；若对数据请求X锁，需等待事务释放锁。

封锁粒度：描述封锁的数据单元大小，粒度越细，并发性越大。

封锁级别：也称一致性级别或隔离度。
* 0级封锁：封锁的事务不重写其他非0级封锁事务未提交的更新数据。
* 1级封锁：被封锁的事务不允许重写存在未提交的更新数据。防止了丢失更新的发生。
* 2级封锁：被封锁的事务即不更新也不读未提交的更新数据。这除了1级封锁的效果，还防止读脏数据。
* 3级封锁：被封锁的事务不读未提交的更新数据，不写任何未提交数据，这除了2级封锁的效果，还防止不可重读的问题。

活锁：由于锁会使一事务处于等待状态，若按优先级排序，该事务可能因为等级过低而永远等下去。
   * 先来先服务

死锁：两个以上事务循环等待，被同组中另一个事务锁住数据单元的情形（你等他、他等你）。
   * 一次锁请求：每一事务在处理时一次提出所有的锁请求，仅当这些请求全部满足时事务才进行处理。
   * 锁请求排序：将每个数据单元标以线性顺序，然后要求每一事务都按此顺序提出锁请求。
   * 序列化处理：设立一个代理程序，对给定数据单元的所有请求都发个该程序。
   * 资源剥夺：每当事务因锁请求不能满足而受阻时，强行令两个冲突事务中的一个ROLLBACK，释放所有的锁，以后再重新运行。

可串行性：一组事务的一个调度就是它们的基本操作的一种排序。在数据库中，可串行性就是并发执行的正确性准则，即当且仅当一组事务的并发执行调度是可串行化的，才认为他们是正确的。

两段封锁法：一种最简单而有效的保障封锁其调度是可串行性的方法，两段封锁法是事务遵循两段锁协议的调度方法。
   * 发展或加锁阶段
   * 收缩或释放锁阶段

### 6.5 备份与恢复

创建备份：将数据库以字符导出到文件
```
SELECT * INTO {OUTFILE|DUMPFILE} filename 
[FIELDS
   [TERMINATED BY 'str']
   [[OPTIONALLY] ENCLOSED BY 'char']
   [ESCAPED BY 'char']
]
[LINE TERMINATED BY 'str']
```
* OUTFILE:有格式文件
* DUMPFILE：无格式文件
* TERMINATED：指定字段值之间的标志
* ENCLOSED：指定字符型数据放置在什么符号之间
* ESCAPED：指定转义符号
* LINE TERMINATED：指定一行数据结束标志

恢复备份：从文件中读取文本以恢复数据库
```
LOAD DATA INFILE filename INTO TABLE tbl_name
[FIELDS
   [TERMINATED BY 'str']
   [[OPTIONALLY] ENCLOSED BY 'char']
   [ESCAPED BY 'char']
]
[LINE
   [STARTING BY 'str']
   [TERMINATED BY 'str']
]
```
* STARTING：指定一个前缀，忽略该前缀以及之前的内容，若某行不包括该前缀，则整个数据行都被跳过。

## 7 数据库应用设计与开发实例
### 7.1 需求描述与分析
`以高校在线选课为例`

功能性需求：
   1. 管理员后台模块：需要提供学生信息管理、教师信息管理、课程信息管理以及班级信息管理
   2. 学生使用模块：需要提供查询课程、浏览所选课程以及查询成绩
   3. 教师使用模块：需要提供我的课程以及学生分数录入

非功能性需求：
   1. 可靠性：非特殊情况要保证正常使用、单位时间内最多允许的故障次数
   2. 正确性：保证数据库中数据的正确和各个功能模块的业务逻辑正确
   3. 兼容性：可以在主流机器上运行
   4. 健壮性：要经常进行健壮性测试，不断加强对非格式化操作的应变能力。

### 7.2 系统设计

功能模块设计：
```mermaid
graph TB
   A(登录验证模块)
   B(管理员后台模块)
   C(学生使用模块)
   D(教师使用模块)
   A-->B
   A-->C
   A-->D
   B1(学生信息管理模块)
   B2(教师信息管理模块)
   B3(课程信息管理模块)
   B4(院系信息管理模块)
   B-->B1
   B-->B2
   B-->B3
   B-->B4
   C1(查询课程模块)
   C2(查询已选课程模块)
   C3(选课及退选模块)
   C4(查询成绩模块)
   C-->C1
   C-->C2
   C-->C3
   C-->C4
   D1(我的课程模块)
   D2(分数录入模块)
   D-->D1
   D-->D2
```
数据库设计：
   1. 确定实体：
      * 学生实体：描述学生学号、姓名、性别等
      * 教师实体：描述教师工号、姓名、性别等
      * 课程实体：描述课程号、课程名、学分等
      * 院系实体：描述院系名称、办公地点、教师人数等
      * 管理员实体：描述管理员姓名、ID、密码等
   2. 局部信息结构：分析实体彼此间存在的相互联系，通过E-R图来表达
   3. 全局信息结构：在构建上述局部信息的基础上，通过采用逐步合成、进行累加的方式，以消除可能存在的属性冲突、命名冲突和结构冲突，最终形成一个本系统的全局信息结构
   4. 逻辑结构与规范化设计：设计本数据库应用软件的基本关系模式

### 7.3 系统实现

数据库实现：首先创建本数据库，然后根据本应用数据库逻辑结构设计所得出的关系模式，在数据库中创建数据表，并建立各表的主键，从而构成主键索引。

系统功能实现：
   1. 实现数据库行为：主要通过SQL语言完成与本应用功能相关的增、删、改、查等数据库操作，也包括为提高数据库操作效率或保护数据库安全而创建的各种数据库对象，如子查询、视图、触发器、存储过程或存储函数等。
   2. 实现应用软件的业务逻辑：根据系统功能设计的结果，分别逐个实现各个功能模块。

### 7.4 系统测试与维护

登录验证功能测试：以学生、教师、管理员身份进行登录操作，验证密码匹配正确与不正确等情形。

管理员后台主要功能测试：学生信息、课程信息表等的增删改查。

学生使用模块功能测试：选课与查询等

教师使用模块功能测试：查看我的课程与分数录入等。

## 8 数据管理技术的发展
### 8.1 数据库技术的发展概述

第一代数据库系统：支持三级模式（外模式、模式、内模式）；用存取路径来表示数据之间的联系；独立数据定义语言；独立数据定义语言；导航的数据操作语言
   * 层次模型数据库管理系统（IMS）：1969年IBM公司研制
   * 网状模型数据库系统：20世纪60年代末70年代初，数据库系统语言研究会（CODASYL）下属的数据库任务组（DBTG）对数据库方法进行系统的研究和探讨后提出

第二代数据库系统：支持关系数据模型的关系数据库系统

新一代数据库系统：支持数据管理、对象管理和知识管理（AI）；保持或继承关系数据库技术；对其他系统开发；

### 8.2 数据仓库与数据挖掘

数据处理工作：
   * 操作型处理：也称为联机事物处理（OLTP），它是针对数据库联机的日常操作，通常对少数记录进行查询和修改
   * 分析型处理：也称为联机分析处理（OLAP），一般针对某些主题的历史数据进行分析，支持管理决策，通常是对海量的历史数据进行查询和分析

数据仓库：面向主题的、集成的、稳定的（非易失）、随时间变化的（实时）数据集合，用以支持管理决策的过程
   * 粒度：指数据仓库的数据单位中保存数据的细化或综合程度的级别。
   * 分割：指将数据分散到各自的物理单元中，以便能分别处理，以提高数据处理的效率。数据分割后的单元成为切片。
   * 维：指人们观察数据的特定角度，是考虑问题时的一类属性。此类属性的集合构成一个维度，如时间维、产品维等。
   * 数据集市：指自下而上的数据仓库的开发方法。数据集市结构的数据仓库，又称为主题结构数据仓库，是按照主题进行构思所形成的数据仓库。

数据挖掘：是从大量的、不完全的、有噪声的、模糊的、随机的实际应用数据中发现并提取隐藏在其中的、人们事先不知道的、但又潜在有用的信息和知识的一种技术。
   * 概念描述：归纳总结出某些数据的特征
   * 关联分析：若两个或多个变量的取值之间存在某种规律性，就称为关联
   * 分类与预测：分类就是找出一个类别的概念描述，它代表了这类数据的整体信息，并用这种描述来构建模型。分类可用于规则的描述和预测
   * 聚类：聚类就是把数据按照相似性归纳若干类别，同一类中的数据彼此相似
   * 孤立点检测：孤立点是指数据中与整体表现行为不一致的数据集合
   * 趋势与演变分析：通过数据挖掘技术，可以描述行为随着时间变化的对象所遵循的规律或趋势。
挖掘过程：
   1. 确定业务对象：将用户需求和目标转换成一种数据挖掘的问题定义
   2. 数据的选择：搜索所有与业务对象有关的内部和外部数据信息，并从中选择适用于数据挖掘应用的数据
   3. 数据的预处理：将最初的原始数据构造成最终适合建模工具处理的数据集，包括表、记录、属性的选择，数据转换和数据清洗等。
   4. 建模：选择和应用各种建模技术，并对模型参数选择合适的算法进行优化
   5. 模型评估：对模型进行评价，并检查构建模型的每个步骤，确认其是否真正实现预定目的
   6. 模型部署：将活动模型应用到决策制定的过程中

### 8.3 大数据管理技术

大数据：无法在可容忍的时间内用现有信息技术和软、硬件工具对其进行感知、获取、管理、处理的数据集合。其具有的特点是：
   * 数据量巨大（volume）
   * 数据种类繁多（variety）
   * 快速化（velocity）
   * 价值（value）密度低

管理技术：
   1. 大数据存储：分布式文件系统用于统一管理服务器节点上存储的数据，典型案例是Hadoop开源框架下的HDFS，它以大粒度数据块的方式存储文件，从而减少了元数据的数量。
   2. NoSQL数据管理系统：NoSQL是以互联网大数据背景发展起来的分布式数据管理系统。有两种解释，非关系数据库和不仅仅是SQL；该系统为了提高存储能力和并发读写能力采用了及其简单的数据模型，支持简单的查询操作，而将复杂操作留给应用层实现；通过大量结点并行处理获得高性能，弥补了传统数据库由于事务等机制而带来的对海量数据高并发请求处理性能上的欠缺，采用一种非关系的方式来解决大数据存储和管理的问题。该系统支持的存储模型通常有键值模型、文档模型、列模型和图模型。
   3. MapReduce技术：以Key/Value的分布式存储系统为基础，通过元数据集中存储、数据以chunk为单位分布存储和数据chunk冗余复制来保证其高可用性。
   
