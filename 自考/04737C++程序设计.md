# C++程序设计
## 1 C++语言简介
### 1.1 C++语言发展史
`C++语言是由Bjarne Stroustrup于1979年在美国贝尔实验室开始设计开发的。1985年推出了1.0版本。`
### 1.2 C++语言语言特点
`C++语言是一种编译式的、通用的、大小写敏感的编程语言。是C语言的继承，增强了C语言对类型的处理以及加入了面向对象的特征。`

**头文件**：C++语言中使用头文件保存应用程序中用到的声明。格式如`#include<头文件名>`，每条仅可包含一个头文件。常用的头文件
   * 标准输入输出流：\<iostream>
   * 标准文件流：\<fstream>
   * 标准字符串处理函数：\<string>
   * 标准数学函数：\<cmath>

**命名空间**：也称为名字空间，为了消除同名引起的歧义。*C++程序标准库中的所有标示符都定义在名为std的命名空间中。如果没有使用语句 `using namespace std;`，则cin和cout都没有定义，string也是如此，甚至endl也不能识别。*
   * 定义：
      ```
      namespace 命名空间名
      {
         函数声明、类声明...
      }
      ```
   * 使用：
      * 命名空间完整引用：`using namespace 命名空间名;`
      * 命名空间标识符引用：`using 命名空间名::标识符名;`

移位运算符：从输入流中获取数据的操作称为提取操作，可以使用流提取运算符“>>”；向输出流中添加数据的操作称为插入操作，可以使用流插入运算符“<<”。

输入（cin）: 从键盘取得输入数据，如`cin>>x`，获取输入数据并赋给变量x。

输出（cout）: 向屏幕设备输出信息，如`cout<<"hello world!";`,向控制台输出hell world！

函数原型：函数与编译器之间的接口。描述函数的返回值以及参数类型，不需要定义每个形参。

`int func(int, int);`

引用：相当于给变量起了个别名，变量对应于某个内存地址；

`类型名 &引用名 = 同类型某个变量名`

传值：传递对象的值。

```
int a = 10;
int b = a;
```

传引用：传递对象的首地址值。
```
int a = 10;
int *b = &a;
int &c = a;
```

强制类型转换运算符：
   * static_cast 用于将一种数据类型转换为另一种数据类型

      `static_cast<类型名>(表达式)`
   * const_cast 用于将常量指针转化为非常量指针，并且仍指向原对象

      `const_cast<类型名>(表达式)`

函数默认值：在声明函数时为形参指定默认值。提供默认值时，必须按从右至左的顺序提供。

`void func(int a, int b = 1, int c = 3)`

const修饰指针变量：
   * 如果唯一的const位于符号*的左侧，表示指针所指的数据是常量，数据不能通过本指针改变，但可以通过其他方式修改；指针本身是变量，可以指向其他的内存单元。
   * 如果唯一的const位于符号*的右侧，表示指针本身是常量，不能让该指针指向其他内存地址，指针所指向的数据可以通过本指针进行修改。
   * 在符号*的左右各有一个const时，表示指针和指针所指的数据都是常量，既不能让指针指向其他地址，也不能通过指针修改所指向的内容。

内联函数：为了解决函数调用会带来程序运行时间上的开销（主调函数现场的保存和恢复），将可复用**语句较少**的代码块抽离形成的函数。在编译时以函数体替换函数表达式，以牺牲空间消耗节省时间开销。

`inline 返回值类型 函数名（形参表）｛｝`

**函数的重载**：多个函数名称相同，但**参数表中对应的参数类型不同**或**参数表中参数个数不同**以完成类似功能但函数不同。如果两个函数的名字和参数表都是一样的，仅仅是返回值类型不同，则这两个函数不是重载的。另外，如果采用引用参数或参数表有默认值的参数，不能区分函数，也不能实现重载。

静态内存分配：在程序**编译时**就能确定占用内存大小的内存分配方式。

`int staticArray[] = {1, 2, 3};`

动态内存分配：在程序**运行时**，根据实际需要，临时分配一段内存空间用于存储数据。

`int *dynamicArray = new int[8];`

内存释放：使用new运算符动态分配的内存空间，一定要用`delete`释放。否则即使程序运行结束，这部分内存空间仍然不会被操作系统回收，从而成为被白白浪费的内存垃圾。这种现象称为内存泄漏。

`delete []dynamicArray;`

**string**: 一个专门处理字符串的类，这种类型的变量称为一个对象。在同一系统下，保存字符串的内存首地址是一样长的，即一个string对象的大小是固定的。string 对象之间可以使用<、<=、==、!=、>=、>运算符进行比较，大小的判断标准是按字典序进行的，而且是大小写相关。

## 2 面向对象的基本概念
### 2.1 结构化程序设计
`在面向对象程序设计出现之前，主流设计方法之一就是结构化程序设计，也叫面向过程的设计方法。`

基本方法：采用自顶向下、逐步求精及模块化的思想，将复杂的大问题层层分解为许多简单的小问题。

基本结构：顺序结构、选择结构、循环结构。

基本思想：数据结构+算法=程序

缺点：模块之间的耦合度高，导致函数之间的调用关系错综复杂，没有有效手段控制函数可以施加操作的范围。

### 2.2 面向对象程序设计的概念和特点

设计方法：使分析、设计和实现一个系统的方法尽可能地接近人认识一个系统的方法。通常包括三个方面：面向对象的分享。面向对象的设计和面向对象的程序设计。

对象：系统中用来描述客观事物的一个实体。用**对象名、属性和操作**三要素来描述对象。

基本特点：
   * 抽象：将同一类事物的特点概括出来的过程。

   * 封装：把对象的属性和操作结合成一个独立的单元。
      * 数据和操作数据的函数紧密联系在一起
      * 将对象的一部分属性和函数隐藏起来，让这部分属性和函数对外不可见，起到保护作用。
      * 将对象的其他属性和函数对外可见，作为对对象进行操作的接口。

   * 继承：以现有的类作为基础，使得新类从现有的类“派生”而来，从而达到**代码扩充和复用**。

   * 多态：不同种类的对象都具有名称相同的行为（方法），而具体行为的实现方式却有所不同。

### 2.3 类的初步认识

概念：具有相同属性和操作的一组对象的集合。其内部包括属性（成员变量）和行为（成员函数）两个部分，即以数据为中心，把相关的一批函数组成一体。

定义约束：
   * 不能在类的声明中对数据变量进行初始化。
   * 类的声明中可以给出成员函数参数的默认值。
   * 类中的任何成员不能使用extern、auto和register关键字修饰。
   * 不含有任何属性和行为的类，称为空类。

定义一个类：

```
class 类名 {
    访问修饰符:
        类型 成员变量;
        类型 成员函数;
}
```

**访问类的成员**：
   * 外部通过类访问成员函数使用类作用域运算符“::”，表示其后面的成员函数属于类名标识的这个类。

      `类名::成员函数名；`
   * 成员函数体中访问成员变量或其他成员函数，可通过成员函数名或成员变量名直接访问。
      ```
      类名::成员函数名(类型 参数名){
         成员变量 = 参数;
         成员函数(参数);
      }
      ```

### 2.4 类的示例程序剖析

定义一个对象：对于使用new创建的对象，必须使用delete来释放内存空间。
   * `类名 对象名;`
   * `类名 对象名(参数);`
   * `类名 对象名 = 类名(参数);`
   * `类名 对象名1, 对象名2, ... ;`
   * `类名 对象名1(参数1), 对象名2(参数2), ... ;`
   * `类名 *对象指针名 = new 类名;`
   * `类名 *对象指针名 = new 类名();`
   * `类名 *对象指针名 = new 类名(参数);`

声明对象引用：
   * `类名 &对象别名 = 对象;`

声明对象指针：
   * `类名 *对象指针名 = &对象;`

声明对象数组：
   * `类名 对象数组名[数组大小];`

声明对象数组指针：
   * `类名 *对象数组指针名[数组大小];`
      * `对象数组指针名 == 对象数组指针名[0]`
         > 默认指向数组第0位
      * `对象数组指针名 = index`
         > 修改指向第index位

关于类与对象:
   * 声明一个类不占内存空间
   * 声明一个对象占用内存空间
   * 实例化对象时，只会分配成员变量的空间，而不会分配成员函数的空间
   * 普通成员函数由类的对象调用，类的静态成员函数由类来调用

### 2.5 访问对象的成员

对象访问成员变量或成员函数：`对象名.成员变量名/成员函数名;`

对象指针访问成员变量或成员函数：`对象指针名->成员变量名/成员函数名;`

### 2.6 类成员可访问范围

访问范围说明符：默认声明为private。
   * private（私有）：只有本类可以访问，派生类和外部不可用访问。
   * protected（保护）：只有本类和派生类可以访问，外部不可访问。
   * public（公有）：本类、派生类、外部都能访问。

### 2.7 标识符的作用域与可见性

**作用域**：变量、常量可访问的范围，需要先声明，后使用。
   * 函数原型作用域：声明函数原型时，形参的作用范围在形参列表的左右括号之间，称为数原型作用域（最小）。
      > `类型 函数名(类型 参数名);`
   * 块作用域：程序中使用相匹配的一对大括号括起来的一段程序称为块，作用域局限在块内的称为局部作用域。
   * 类作用域：类可以被看成是一组有名字的成员的集合，类X对成员m具有类作用域。
   * 命名空间作用域：命名空间是为了消除同名引起的歧义，一个命名空间确定了一个命名空间作用域。
   * 文件作用域：也称为单文件作用域，从定义处开始，到整个源文件结束。文件中定义的全局变量和函数都具有文件作用域。
   * 程序作用域：也称为多文件作用域，使用extern关键字进行声明的外部变量或函数。

**可见性原则**：
   * 标识符声明在前，引用在后。
   * 在同一个作用域中，不能声明同名标识符。
   * 如果存在两个或多个包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层可见。如果在内层声明了同名标识符，在外层标识符在内层不可见，这时称内层标识符隐藏了外层同名标识符。

## 3 类和对象进阶
### 3.1 构造函数

**声明**：在声明构造函数是可以同时给出函数体，这样的构造函数称为内联函数，也可以在类体外给出构造函数的定义。

   `类名(形参1, 形参2, ...., 形参n)`

**定义**：当类中没有定义构造函数时，系统会自动添加一个参数为空，函数体也为空的默认构造函数。

* ```
   // 将传入实参赋值给对应成员属性
   类名:类名(形参1, 形参2, ..., 形参n)
   {
      x1 = 形参1;
      x2 = 形参2;
      ...
      xn = 形参n;
   }
   ```
* <i id="define-member-by-list">列表方式</i>
   ```
   // 将传入实参赋值给对应成员属性
   类名:类名(形参1, 形参2, ..., 形参n):x1(形参1), x2(形参2), ..., xn(形参n)
   {
   }

   ```
* ```
   // 不通过传入参数完成初始化
   类名:类名()
   {
      x1 = 表达式1;
      x2 = 表达式2;
      ...
      xn = 表达式n；
   }

   ```

**约束**：
   1. 构造函数的名字必须和类名相同；
   2. 定义构造函数是不能指定返回类型，即使是void也不可以；
   3. 类可有多个构造函数，即支持函数重载；
   4. 构造函数的参数在排列时无顺序要求，只需在声明形参和使用形参相互对应即可。
   5. 构造函数可以使用默认参数。

**创建对象**：通过调用定义的构造函数完成初始化，未定义构造函数则调用默认构造函数。
   * `类名 对象名;`
   * `类名 对象名();`
   * `类名 对象名(参数1, 参数2, ...., 参数n);`
   * `类名 *对象指针名 = new 类名();`
      > 若用户未定义构造函数，系统为成员变量分配内存的同时，将其初始化为0。
   * `类名 *对象指针名 = new 类名;`
      > 若用户未定义构造函数，系统只为成员变量分配内存空间，但不进行初始化，成员变量的值是随机的。

复制构造函数：使用一个已存在的对象去初始化另一个正在创建的对象，参数为本类型对象的一个引用的构造函数。
   * `类名::类名(类名 &对象名);`
   * `类名::类名(const 类名 &对象名);`
      > 初始化后不能改变的对象。

自动调用复制构造函数的场景：可以理解为传引用时都会自动调用赋值构造函数。
   * 当用一个对象去初始化本类的另一个对象时：
      * `类名 对象名2（对象名1）;`
      * `类名 对象名2 = 对象名1;`
   * 当调用某函数需要传入某类型对象时：
      * `函数(类名 对象名);`
   * 当调用某函数返回值为某类型对象时：
      * `类名 函数();`

类型转换构造函数：只有一个参数的构造函数。

### 3.2 析构函数
`类只能定义一个析构函数，且不能指明参数；如果程序中没有定义析构函数，则编译器自动生成默认的空函数体析构函数。`

作用：在对象消失时，释放由构造函数分配的内存；

声明：`~类名()`;

定义：`类名::~类名(){}`;

原则：
   * 使用new运算符动态分配的内存空间，在析构函数中应该使用delete释放掉这部分占用的内存空间。
   * 当程序先后创建了几个对象时，系统按照**后建先析构**的原则析构对象。
   * 当使用delete调用析构函数是，则安delete的顺序析构。

### 3.3 类的静态成员

**静态变量**：static修饰的、仅在所在块第一次执行时完成初始化的变量。若未给初始值，系统自动分配0；
   * 静态全局变量：在所有花括号之外声明的变量，作用域范围为定义该变量的源*文件*内。
   * 静态局部变量：在函数代码块内声明的变量，作用域范围为定义该变量的*块*内；具有全局生存期，它占据的空间一直到程序结束时才释放。

**类的静态成员**：static修饰的成员变量或成员函数。定义类静态成员变量时，在定义中声明静态成员变量，然后必须在类体外定义静态成员变量的初值。
> `类名::静态成员变量名 = 初值`

**静态成员与一般成员的不同**：
   1. 可以不指向某个具体的对象，只与类名连用；
   2. 在没有建立对象之前，静态成员就已存在；
   3. 静态成员是类的成员，不是对象的成员；
   4. 静态成员为该类所有对象共享，它们被存储于一个公用的内存中，各个对象看到的值都是一样的；
   5. 没有this指针，只能通过对象名火指向对象的指针访问内的数据成员；
   6. 静态成员函数不能被说明为虚函数；
   7. 静态成员函数不能直接访问非静态函数；

### 3.4 变量及对象的生存周期和作用域

变量的生存期：变量所占据的内存空间由分配到释放的时期；

变量的作用域：变量的有效范围（可访问范围）；

外部变量：属于程序作用域或多文件作用域，通过extern关键字进行声明的外部变量。

全局变量：程序中定义在所有函数（包括main函数）之外的任何变量，其作用域是从变量定义到整个程序结束的部分；起生存期为整个程序的执行期间；

局部变量：在函数内或程序块内定义的变量，其作用域是函数体内或程序块内（一对大括号括起来的程序段）；起生成器为从被定义开始，到所在函数或程序块结束处结束；

### 3.5 常量成员和常引用成员

类常量成员变量：由关键字const修饰的类成员变量；必须且只能通过构造函数的成员初始化以[列表方式](#define-member-by-list)进行；
   * 定义常量成员变量或常量对象：`const 数据类型 常量名 = 表达式;`
      > 声明常量对象后，不允许修改常量成员变量的值；不能通过常量对象调用普通成员函数。
   * 定义常量成员函数或常量函数：`返回值类型 函数名（参数表）const;`
      > 不能在常量函数中调用普通函数（静态成员函数除外）。

常引用：使用引用作为函数参数，传送的是地址，形参改变，实参也会跟着改变；但如果不希望函数改变对象的值，就要使用常引用作为参数。
   > `返回值类型 函数名(const &形参名){};`

### 3.6 成员对象和封闭类
`一个类的成员变量如果是另一个类的对象，则该成员称为“成员变量”。这两个类为包含关系。包含成员对象的类叫做封闭类。`

* 封闭类对象生成时，先执行所有成员对象的构造函数，然后执行封闭类自己的构造函数。
* 成员对象构造函数的执行次序与成员对象在类定义中的说明次序一直，与他们在构造函数初始化列表中出现的次序无关。
* 当封闭类对象消亡时，先执行封闭类的析构函数，然后在执行成员对象的析构函数；成员对象析构函数的执行次序与构造函数执行次序相反，即**先构造的后析构**。
* 封闭类的对象是用默认赋值构造函数初始化的，那么它包含的成员对象也会用复制构造函数初始化。

### 3.7 友元
`面向对象程序设计要求在类外不能访问类的私有成员变量，而必须通过公有的成员函数来访问。这样的设计风格，使得程序在书写上比较麻烦。友元机制是对一些类外函数打开一个特殊通道，授权他们访问本类的私有成员变量。`

`友元使用关键字friend标识。在类定义中，当friend出现在函数说明语句前面时，表示该函数为本类的友元函数。一个函数可以同时说明为多个类的友元函数，一个类也可以有多个友元函数。当friend出现在类名之前时，表示该类为友元类。`

声明：友元函数不是类的成员函数，但允许访问类中所有的成员。包括private、protected、public
   * 全局友元函数：
      > `friend 返回值类型 函数名(参数表);`
   * 将其他类的成员函数说明为本类的友元函数：
      > `friend 返回值类型 其他类::其他类的成员函数名(参数表);`
   * 将其他类声明为本类的友元类：如果将一个类B声明为另一个类A的友元类，则类B中所有的成员函数都可以访问类A中的所有成员。
      > `friend class 类名;`

约束：
   * 不能把其他类的私有成员函数声明为友元函数。
   * 友元类是单向的，若定义类B是类A的友元类，不等于类A也是类B的友元类。
   * 友元类的关系是不能传递的，即若定义类B是类A的友元类，类C是类B的友元类，不等于类C是类A的友元类。
   * 除非的确有必要，一般不把整个类说明为友元类，而仅把类中的某些成员函数定义为友元函数。

### 3.8 this指针
`当调用一个成员函数时，系统自动向他传递一个隐含参数，该参数是一个指向调用该函数的对象的指针，称为this指针，从而使成员函数知道对哪个对象进行操作。`

`静态成员是类具有的属性，不是对象的特征，静态成员函数没有this指针。`

## 4 运算符重载
### 4.1 运算符重载的概念
`给已有运算符赋予多重含义，使同一个运算符作用于不同类型的数据时产生不同的行为`

**实质**：编写以运算符为名称的函数，使用运算符表达式就被解释为对重载函数的调用。
* 重载为全局函数： `返回值类型 operator 运算符(形参表) {函数体}`
* 重载为类的成员函数：`返回值类型 类名::operator 运算符(形参表) {函数体}`
* 重载为类的友元函数：`friend 返回值类型 类名::operator 运算符(形参表) {函数体}`

约束：
   1. 重载后的运算符含义应该符合原有的用法习惯，如不能重载"+"做减法
   2. 运算符重载后不能改变运算符原有的语义，包括优先级和结合性
   3. 运算符重载后不能改变运算符操作数的个数及语法结构
   4. 不能创建新的运算符，即重组运算符不能超过语言允许重载的运算符范围
   5. 重载运算符 "()", "[]", "->" 或 "=" 时，只能将他们重载为成员函数，**不能重载为全局函数**
   6. 运算符重载不能改变运算符用于基本数据类型对象的含义，如可以用于用户自定义类型的对象之间的运算。

可重载运算符||
---|:--
双目运算符| +, -, *, /, %
关系运算符| ==, !=, <, >, <=, >=
逻辑运算符| \|\|, &&, !
单目运算符| +, -, *(指针), &(取地址)
自增自减运算符| ++, --
位运算符| \|(按位或), &(按位与), ~(按位取反), ^(按位异或), <<(左移), >>(右移)
赋值运算符| =, +=, -=, *=, /=, %=, &=, \|=, ^=, <<=, >>= 
空间申请与释放| new, delete, new\[](创建数组), delete\[](释放数组)
其他运算符| ()(函数调用), ->(成员访问), ,(逗号), [](下标)

不可重载运算符||
---|:--
成员访问运算符| .
成员指针访问运算符| .\*, ->*
域运算符| ::
长度运算符| sizeof
条件运算符| ?:
预处理运算符| #

### 4.2 重载赋值运算符

浅拷贝：没有经过重载的复制运算符，赋值语句是将一个对象中指针成员变量赋值给其他对象，但对象中的指针指向的是同一个内存地址，一个值发生了变化，另一个值也会发生变化。

浅拷贝：重载赋值运算符后，赋值语句是将一个对象中指针成员变量指向的内容复制到另一个对象中指针成员变量的地方。