# C++程序设计
## 1 C++语言简介
### 1.1 C++语言发展史
`C++语言是由Bjarne Stroustrup于1979年在美国贝尔实验室开始设计开发的。1985年推出了1.0版本。`
### 1.2 C++语言语言特点
`C++语言是一种编译式的、通用的、大小写敏感的编程语言。是C语言的继承，增强了C语言对类型的处理以及加入了面向对象的特征。`

**头文件**：C++语言中使用头文件保存应用程序中用到的声明。格式如`#include<头文件名>`，每条仅可包含一个头文件。常用的头文件
   * 标准输入输出流：\<iostream>
   * 标准文件流：\<fstream>
   * 标准字符串处理函数：\<string>
   * 标准数学函数：\<cmath>

**命名空间**：也称为名字空间，为了消除同名引起的歧义。*C++程序标准库中的所有标示符都定义在名为std的命名空间中。如果没有使用语句 `using namespace std;`，则cin和cout都没有定义，string也是如此，甚至endl也不能识别。*
   * 定义：
      ```
      namespace 命名空间名
      {
         函数声明、类声明...
      }
      ```
   * 使用：
      * 命名空间完整引用：`using namespace 命名空间名;`
      * 命名空间标识符引用：`using 命名空间名::标识符名;`

移位运算符：从输入流中获取数据的操作称为提取操作，可以使用流提取运算符“>>”；向输出流中添加数据的操作称为插入操作，可以使用流插入运算符“<<”。

输入（cin）: 从键盘取得输入数据，如`cin>>x`，获取输入数据并赋给变量x。

输出（cout）: 向屏幕设备输出信息，如`cout<<"hello world!";`,向控制台输出hell world！

函数原型：函数与编译器之间的接口。描述函数的返回值以及参数类型，不需要定义每个形参。

`int func(int, int);`

引用：相当于给变量起了个别名，变量对应于某个内存地址；

`类型名 &引用名 = 同类型某个变量名`

传值：传递对象的值。

```
int a = 10;
int b = a;
```

传引用：传递对象的首地址值。
```
int a = 10;
int *b = &a;
int &c = a;
```

强制类型转换运算符：
   * static_cast 用于将一种数据类型转换为另一种数据类型

      `static_cast<类型名>(表达式)`
   * const_cast 用于将常量指针转化为非常量指针，并且仍指向原对象

      `const_cast<类型名>(表达式)`

函数默认值：在声明函数时为形参指定默认值。提供默认值时，必须按从右至左的顺序提供。

`void func(int a, int b = 1, int c = 3)`

const修饰指针变量：
   * 如果唯一的const位于符号*的左侧，表示指针所指的数据是常量，数据不能通过本指针改变，但可以通过其他方式修改；指针本身是变量，可以指向其他的内存单元。
   * 如果唯一的const位于符号*的右侧，表示指针本身是常量，不能让该指针指向其他内存地址，指针所指向的数据可以通过本指针进行修改。
   * 在符号*的左右各有一个const时，表示指针和指针所指的数据都是常量，既不能让指针指向其他地址，也不能通过指针修改所指向的内容。

内联函数：为了解决函数调用会带来程序运行时间上的开销（主调函数现场的保存和恢复），将可复用**语句较少**的代码块抽离形成的函数。在编译时以函数体替换函数表达式，以牺牲空间消耗节省时间开销。

`inline 返回值类型 函数名（形参表）｛｝`

**函数的重载**：多个函数名称相同，但**参数表中对应的参数类型不同**或**参数表中参数个数不同**以完成类似功能但函数不同。如果两个函数的名字和参数表都是一样的，仅仅是返回值类型不同，则这两个函数不是重载的。另外，如果采用引用参数或参数表有默认值的参数，不能区分函数，也不能实现重载。

静态内存分配：在程序**编译时**就能确定占用内存大小的内存分配方式。

`int staticArray[] = {1, 2, 3};`

动态内存分配：在程序**运行时**，根据实际需要，临时分配一段内存空间用于存储数据。

`int *dynamicArray = new int[8];`

内存释放：使用new运算符动态分配的内存空间，一定要用`delete`释放。否则即使程序运行结束，这部分内存空间仍然不会被操作系统回收，从而成为被白白浪费的内存垃圾。这种现象称为内存泄漏。

`delete []dynamicArray;`

**string**: 一个专门处理字符串的类，这种类型的变量称为一个对象。在同一系统下，保存字符串的内存首地址是一样长的，即一个string对象的大小是固定的。string 对象之间可以使用<、<=、==、!=、>=、>运算符进行比较，大小的判断标准是按字典序进行的，而且是大小写相关。

## 2 面向对象的基本概念
### 2.1 结构化程序设计
`在面向对象程序设计出现之前，主流设计方法之一就是结构化程序设计，也叫面向过程的设计方法。`

基本方法：采用自顶向下、逐步求精及模块化的思想，将复杂的大问题层层分解为许多简单的小问题。

基本结构：顺序结构、选择结构、循环结构。

基本思想：数据结构+算法=程序

缺点：模块之间的耦合度高，导致函数之间的调用关系错综复杂，没有有效手段控制函数可以施加操作的范围。

### 2.2 面向对象程序设计的概念和特点

设计方法：使分析、设计和实现一个系统的方法尽可能地接近人认识一个系统的方法。通常包括三个方面：面向对象的分享。面向对象的设计和面向对象的程序设计。

对象：系统中用来描述客观事物的一个实体。用**对象名、属性和操作**三要素来描述对象。

基本特点：
   * 抽象：将同一类事物的特点概括出来的过程。

   * 封装：把对象的属性和操作结合成一个独立的单元。
      * 数据和操作数据的函数紧密联系在一起
      * 将对象的一部分属性和函数隐藏起来，让这部分属性和函数对外不可见，起到保护作用。
      * 将对象的其他属性和函数对外可见，作为对对象进行操作的接口。

   * 继承：以现有的类作为基础，使得新类从现有的类“派生”而来，从而达到**代码扩充和复用**。

   * 多态：不同种类的对象都具有名称相同的行为（方法），而具体行为的实现方式却有所不同。

### 2.3 类的初步认识

概念：具有相同属性和操作的一组对象的集合。其内部包括属性（成员变量）和行为（成员函数）两个部分，即以数据为中心，把相关的一批函数组成一体。

定义约束：
   * 不能在类的声明中对数据变量进行初始化。
   * 类的声明中可以给出成员函数参数的默认值。
   * 类中的任何成员不能使用extern、auto和register关键字修饰。
   * 不含有任何属性和行为的类，称为空类。

定义一个类：

```
class 类名 {
    访问修饰符:
        类型 成员变量;
        类型 成员函数;
}
```

**访问类的成员**：
   * 外部通过类访问成员函数使用类作用域运算符“::”，表示其后面的成员函数属于类名标识的这个类。

      `类名::成员函数名；`
   * 成员函数体中访问成员变量或其他成员函数，可通过成员函数名或成员变量名直接访问。
      ```
      类名::成员函数名(类型 参数名){
         成员变量 = 参数;
         成员函数(参数);
      }
      ```

### 2.4 类的示例程序剖析

定义一个对象：对于使用new创建的对象，必须使用delete来释放内存空间。
   * `类名 对象名;`
   * `类名 对象名(参数);`
   * `类名 对象名 = 类名(参数);`
   * `类名 对象名1, 对象名2, ... ;`
   * `类名 对象名1(参数1), 对象名2(参数2), ... ;`
   * `类名 *对象指针名 = new 类名;`
   * `类名 *对象指针名 = new 类名();`
   * `类名 *对象指针名 = new 类名(参数);`

声明对象引用：
   * `类名 &对象别名 = 对象;`

声明对象指针：
   * `类名 *对象指针名 = &对象;`

声明对象数组：
   * `类名 对象数组名[数组大小];`

声明对象数组指针：
   * `类名 *对象数组指针名[数组大小];`
      * `对象数组指针名 == 对象数组指针名[0]`
         > 默认指向数组第0位
      * `对象数组指针名 = index`
         > 修改指向第index位

关于类与对象:
   * 声明一个类不占内存空间
   * 声明一个对象占用内存空间
   * 实例化对象时，只会分配成员变量的空间，而不会分配成员函数的空间
   * 普通成员函数由类的对象调用，类的静态成员函数由类来调用

### 2.5 访问对象的成员

对象访问成员变量或成员函数：`对象名.成员变量名/成员函数名;`

对象指针访问成员变量或成员函数：`对象指针名->成员变量名/成员函数名;`

### 2.6 类成员可访问范围

访问范围说明符：默认声明为private。
   * private（私有）：只有本类可以访问，派生类和外部不可用访问。
   * protected（保护）：只有本类和派生类可以访问，外部不可访问。
   * public（公有）：本类、派生类、外部都能访问。

### 2.7 标识符的作用域与可见性

**作用域**：变量、常量可访问的范围，需要先声明，后使用。
   * 函数原型作用域：声明函数原型时，形参的作用范围在形参列表的左右括号之间，称为数原型作用域（最小）。
      > `类型 函数名(类型 参数名);`
   * 块作用域：程序中使用相匹配的一对大括号括起来的一段程序称为块，作用域局限在块内的称为局部作用域。
   * 类作用域：类可以被看成是一组有名字的成员的集合，类X对成员m具有类作用域。
   * 命名空间作用域：命名空间是为了消除同名引起的歧义，一个命名空间确定了一个命名空间作用域。
   * 文件作用域：也称为单文件作用域，从定义处开始，到整个源文件结束。文件中定义的全局变量和函数都具有文件作用域。
   * 程序作用域：也称为多文件作用域，使用extern关键字进行声明的外部变量或函数。

**可见性原则**：
   * 标识符声明在前，引用在后。
   * 在同一个作用域中，不能声明同名标识符。
   * 如果存在两个或多个包含关系的作用域，外层声明了一个标识符，而内层没有再次声明同名标识符，那么外层标识符在内层可见。如果在内层声明了同名标识符，在外层标识符在内层不可见，这时称内层标识符隐藏了外层同名标识符。

## 3 类和对象进阶
### 3.1 构造函数

**声明**：在声明构造函数是可以同时给出函数体，这样的构造函数称为内联函数，也可以在类体外给出构造函数的定义。

   `类名(形参1, 形参2, ...., 形参n)`

**定义**：当类中没有定义构造函数时，系统会自动添加一个参数为空，函数体也为空的默认构造函数。

* ```
   // 将传入实参赋值给对应成员属性
   类名:类名(形参1, 形参2, ..., 形参n)
   {
      x1 = 形参1;
      x2 = 形参2;
      ...
      xn = 形参n;
   }
   ```
* <i id="define-member-by-list">列表方式</i>
   ```
   // 将传入实参赋值给对应成员属性
   类名:类名(形参1, 形参2, ..., 形参n):x1(形参1), x2(形参2), ..., xn(形参n)
   {
   }

   ```
* ```
   // 不通过传入参数完成初始化
   类名:类名()
   {
      x1 = 表达式1;
      x2 = 表达式2;
      ...
      xn = 表达式n；
   }

   ```

**约束**：
   1. 构造函数的名字必须和类名相同；
   2. 定义构造函数是不能指定返回类型，即使是void也不可以；
   3. 类可有多个构造函数，即支持函数重载；
   4. 构造函数的参数在排列时无顺序要求，只需在声明形参和使用形参相互对应即可。
   5. 构造函数可以使用默认参数。

**创建对象**：通过调用定义的构造函数完成初始化，未定义构造函数则调用默认构造函数。
   * `类名 对象名;`
   * `类名 对象名();`
   * `类名 对象名(参数1, 参数2, ...., 参数n);`
   * `类名 *对象指针名 = new 类名();`
      > 若用户未定义构造函数，系统为成员变量分配内存的同时，将其初始化为0。
   * `类名 *对象指针名 = new 类名;`
      > 若用户未定义构造函数，系统只为成员变量分配内存空间，但不进行初始化，成员变量的值是随机的。

复制构造函数：使用一个已存在的对象去初始化另一个正在创建的对象，参数为本类型对象的一个引用的构造函数。
   * `类名::类名(类名 &对象名);`
   * `类名::类名(const 类名 &对象名);`
      > 初始化后不能改变的对象。

自动调用复制构造函数的场景：可以理解为传引用时都会自动调用赋值构造函数。
   * 当用一个对象去初始化本类的另一个对象时：
      * `类名 对象名2（对象名1）;`
      * `类名 对象名2 = 对象名1;`
   * 当调用某函数需要传入某类型对象时：
      * `函数(类名 对象名);`
   * 当调用某函数返回值为某类型对象时：
      * `类名 函数();`

类型转换构造函数：只有一个参数的构造函数。

### 3.2 析构函数
`类只能定义一个析构函数，且不能指明参数；如果程序中没有定义析构函数，则编译器自动生成默认的空函数体析构函数。`

作用：在对象消失时，释放由构造函数分配的内存；

声明：`~类名()`;

定义：`类名::~类名(){}`;

原则：
   * 使用new运算符动态分配的内存空间，在析构函数中应该使用delete释放掉这部分占用的内存空间。
   * 当程序先后创建了几个对象时，系统按照**后建先析构**的原则析构对象。
   * 当使用delete调用析构函数是，则安delete的顺序析构。

### 3.3 类的静态成员

**静态变量**：static修饰的、仅在所在块第一次执行时完成初始化的变量。若未给初始值，系统自动分配0；
   * 静态全局变量：在所有花括号之外声明的变量，作用域范围为定义该变量的源*文件*内。
   * 静态局部变量：在函数代码块内声明的变量，作用域范围为定义该变量的*块*内；具有全局生存期，它占据的空间一直到程序结束时才释放。

**类的静态成员**：static修饰的成员变量或成员函数。定义类静态成员变量时，在定义中声明静态成员变量，然后必须在类体外定义静态成员变量的初值。
> `类名::静态成员变量名 = 初值`

**静态成员与一般成员的不同**：
   1. 可以不指向某个具体的对象，只与类名连用；
   2. 在没有建立对象之前，静态成员就已存在；
   3. 静态成员是类的成员，不是对象的成员；
   4. 静态成员为该类所有对象共享，它们被存储于一个公用的内存中，各个对象看到的值都是一样的；
   5. 没有this指针，只能通过对象名火指向对象的指针访问内的数据成员；
   6. 静态成员函数不能被说明为虚函数；
   7. 静态成员函数不能直接访问非静态函数；

### 3.4 变量及对象的生存周期和作用域

变量的生存期：变量所占据的内存空间由分配到释放的时期；

变量的作用域：变量的有效范围（可访问范围）；

外部变量：属于程序作用域或多文件作用域，通过extern关键字进行声明的外部变量。

全局变量：程序中定义在所有函数（包括main函数）之外的任何变量，其作用域是从变量定义到整个程序结束的部分；起生存期为整个程序的执行期间；

局部变量：在函数内或程序块内定义的变量，其作用域是函数体内或程序块内（一对大括号括起来的程序段）；起生成器为从被定义开始，到所在函数或程序块结束处结束；

### 3.5 常量成员和常引用成员

类常量成员变量：由关键字const修饰的类成员变量；必须且只能通过构造函数的成员初始化以[列表方式](#define-member-by-list)进行；
   * 定义常量成员变量或常量对象：`const 数据类型 常量名 = 表达式;`
      > 声明常量对象后，不允许修改常量成员变量的值；不能通过常量对象调用普通成员函数。
   * 定义常量成员函数或常量函数：`返回值类型 函数名（参数表）const;`
      > 不能在常量函数中调用普通函数（静态成员函数除外）。

常引用：使用引用作为函数参数，传送的是地址，形参改变，实参也会跟着改变；但如果不希望函数改变对象的值，就要使用常引用作为参数。
   > `返回值类型 函数名(const &形参名){};`

### 3.6 成员对象和封闭类
`一个类的成员变量如果是另一个类的对象，这两个类为包含关系。包含成员对象的类叫做封闭类。`

* 封闭类对象生成时，先执行所有成员对象的构造函数，然后执行封闭类自己的构造函数。
* 成员对象构造函数的执行次序与成员对象在类定义中的说明次序一直，与他们在构造函数初始化列表中出现的次序无关。
* 当封闭类对象消亡时，先执行封闭类的析构函数，然后在执行成员对象的析构函数；成员对象析构函数的执行次序与构造函数执行次序相反，即**先构造的后析构**。
* 封闭类的对象是用默认赋值构造函数初始化的，那么它包含的成员对象也会用复制构造函数初始化。

### 3.7 友元
`面向对象程序设计要求在类外不能访问类的私有成员变量，而必须通过公有的成员函数来访问。这样的设计风格，使得程序在书写上比较麻烦。友元机制是对一些类外函数打开一个特殊通道，授权他们访问本类的私有成员变量。`

`友元使用关键字friend标识。在类定义中，当friend出现在函数说明语句前面时，表示该函数为本类的友元函数。一个函数可以同时说明为多个类的友元函数，一个类也可以有多个友元函数。当friend出现在类名之前时，表示该类为友元类。`

声明：友元函数不是类的成员函数，但允许访问类中所有的成员。包括private、protected、public
   * 全局友元函数：
      > `friend 返回值类型 函数名(参数表);`
   * 将其他类的成员函数说明为本类的友元函数：
      > `friend 返回值类型 其他类::其他类的成员函数名(参数表);`
   * 将其他类声明为本类的友元类：如果将一个类B声明为另一个类A的友元类，则类B中所有的成员函数都可以访问类A中的所有成员。
      > `friend class 类名;`

约束：
   * 不能把其他类的私有成员函数声明为友元函数。
   * 友元类是单向的，若定义类B是类A的友元类，不等于类A也是类B的友元类。
   * 友元类的关系是不能传递的，即若定义类B是类A的友元类，类C是类B的友元类，不等于类C是类A的友元类。
   * 除非的确有必要，一般不把整个类说明为友元类，而仅把类中的某些成员函数定义为友元函数。

### 3.8 this指针
`当调用一个成员函数时，系统自动向他传递一个隐含参数，该参数是一个指向调用该函数的对象的指针，称为this指针，从而使成员函数知道对哪个对象进行操作。`

`静态成员是类具有的属性，不是对象的特征，静态成员函数没有this指针。`

## 4 运算符重载
### 4.1 运算符重载的概念
`给已有运算符赋予多重含义，使同一个运算符作用于不同类型的数据时产生不同的行为`

**实质**：编写以运算符为名称的函数，使用运算符表达式就被解释为对重载函数的调用。
* 重载为全局函数： `返回值类型 operator<运算符>(形参表) {函数体}`
* 重载为类的成员函数：`返回值类型 类名::operator<运算符>(形参表) {函数体}`
* 重载为类的友元函数：`friend 返回值类型 operator<运算符>(形参表) {函数体}`

约束：
   1. 重载后的运算符含义应该符合原有的用法习惯，如不能重载"+"做减法
   2. 运算符重载后不能改变运算符原有的语义，包括优先级和结合性
   3. 运算符重载后不能改变运算符操作数的个数及语法结构
   4. 不能创建新的运算符，即重组运算符不能超过语言允许重载的运算符范围
   5. 重载运算符 "**()**", "**[]**", "**->**" 或 "**=**" 时，**只能重载为成员函数**，不能重载为友元函数
   6. 运算符重载不能改变运算符用于基本数据类型对象的含义，如可以用于用户自定义类型的对象之间的运算。

可重载运算符||
---|:--
双目运算符| +, -, *, /, %
关系运算符| ==, !=, <, >, <=, >=
逻辑运算符| \|\|, &&, !
单目运算符| +, -, *(指针), &(取地址)
自增自减运算符| ++, --
位运算符| \|(按位或), &(按位与), ~(按位取反), ^(按位异或), <<(左移), >>(右移)
赋值运算符| =, +=, -=, *=, /=, %=, &=, \|=, ^=, <<=, >>= 
空间申请与释放| new, delete, new\[](创建数组), delete\[](释放数组)
其他运算符| ()(函数调用), ->(成员访问), ,(逗号), \[](下标)

不可重载运算符||
---|:--
成员访问运算符| .
成员指针访问运算符| .\*, ->*
域运算符| ::
长度运算符| sizeof
条件运算符| ?:
预处理运算符| #

### 4.2 重载赋值运算符

赋值运算符(=)：在类的运算中，默认被重载为对象成员变量的复制。

地址运算符(&)：在类的运算中，默认被重载为返回对象的地址。

约束: 为了保持通常意义下的赋值运算符功能一致，应该让重载的赋值运算符仍然能连续使用过，即"a=b=c;"应成立，所以operator=函数通常要返回**引用**：`返回值类型 & 类名::operator<运算符>(形参表) {函数体}`

浅拷贝：没有经过重载的复制运算符，赋值语句是将一个对象中指针成员变量赋值给其他对象，但对象中的指针指向的是同一个内存地址，一个值发生了变化，另一个值也会发生变化。

浅拷贝：重载赋值运算符后，赋值语句是将一个对象中指针成员变量指向的内容复制到另一个对象中指针成员变量的地方。

### 4.3 重载流插入运算符和重载流提取运算符
`在类库提供的头文件中已经对"<<"和">>"进行了重载，使之分别作为流插入运算符和流提取运算符，与cout和cin一起使用，对基本类型数据进行输出/输入`

重载流插入运算符：
```
ostream &operator<<(ostream & out, 类名 & 对象名){
   out<<"值："<<对象名.属性名<<endl;
   return out;
}
```

重载流提取运算符：
```
ostream &operator>>(ostream & in, 类名 & 对象名){
   string s;
   in>>s; // 记录键盘输入到s变量
   ...
   return in;
}
```

约束：**流插入、流提取运算符只能重载为类的友元函数**；

### *4.4 重载强制类型转换运算符
`类型的名字（包括类的名字）本身也是一种运算符，即强制类型转换运算符。强制类型转换符是单目运算符。`

* `(类型名)对象名`
* `对象.operator<类型名>()`

约束：
   * **强制类型转换运算符只能重载为成员函数**，不能重载为全局函数。
   * 不能指定返回值类型，返回值类型只能是运算符本身代表的类型。

### *4.5 重载自增、自减运算符

* 前置表达式： 返回被修改后的值
   * 声明： `返回值类型 & 类名::operator<++ | -->(){}`
      > 使用：`++obj` 或 `--obj` 等价于 `obj.operator++()` 或 `obj.operator--()`
   * 声明： `friend 返回值类型 & operator<++ | -->(){}`
      > 使用：`operator++(obj)` 或 `operator--(obj)`

* 后置表达式： 返回被修改前的值，重载声明相较于前置表达式，使用int型参数标示
   * `返回值类型 & 类名::operator<++ | -->(int) {}`
      > `obj++` 或 `obj--` 等价于 `obj.operator++(0)` 或 `obj.operator--(0)`
   * 声明： `friend 返回值类型 operator<++ | -->(int){}`
      > 使用：`operator++(obj, 0)` 或 `operator--(obj, 0)`

## 5 类的继承与派生
### 5.1 类的继承与类的派生
`通过已有的类建立新类的过程，叫做类的派生。原来的类叫做基类，也称为父类。新类称为派生类，也称子类。`

`类的派生过程中，基类的构造函数和析构函数不被继承。派生类定义构造函数时，需要声明对基类构造函数的调用；`

**派生类的定义**：
```
class 派生类名:继承方式说明符 基类名1, 继承方式说明符 基类名2 {
   private：
      类型 属性1;
   public:
      派生类名(类型 形参1，类型 形参2, 类型 形参3): 基类名1(形参1), 基类名2(形参2), 属性1(形参3) {
      }
}
```

类的大小：
   * 空类的大小是 1
   * 对象的大小与普通成员变量有关，与成员函数、静态成员变量无关。


**继承方式说明符**：指明基类成员在派生类中的访问属性，未指定时为private
   * public（公有继承）：基类的公有成员和保护成员的访问属性在派生类中不变，而基类的私有成员在基类外不可直接访问（只能调用基类的公有成员函数访问私有成员）
   * protected（保护继承）：基类的公有成员和保护成员都以保护成员的身份出现在派生类中，而基类的私有成员不可直接访问（同上）
   * private（私有继承）：基类的公有成员和保护成员都以私有成员出现在派生类中，而基类的私有成员在派生类中不可直接访问（同上）；当该派生类被作为基类继承时，一级基类的所有成员将无法被访问到。

继承关系的特殊性：
   * 友元：如果基类有友元类或友元函数，派生类不会因为继承关系也有此友元类或友元函数；如果基类是某类的友元，这种友元关系是会被继承的
   * 静态成员：如果基类的静态成员是公有或保护的，会被其他派生类继承为派生类的静态成员，但它们是基类和派生类所共享的。

有继承关系的类之间的访问：
   * 派生类中的成员函数可以访问基类中的公有/保护成员变量，但不能访问基类中的私有成员变量
   * 基类成员和派生类新增的成员都具有类作用域，如果派生类声明了一个和基类某个成员同名的新成员，派生类就隐藏了基类的同名成员（**二义性问题**）；如果派生类声明了与基类成员函数同名的新函数，及时函数的参数表不同，从基类继承的同名函数所有的重载形式也会被隐藏。如果需要访问被隐藏的成员，就需要使用基类名和作用域分辨符来判断：
      * 对象中访问：`对象名.基类名::成员名`
      * 类中访问：`基类名::成员名`

### 5.2 访问控制

类型兼容规则：指在需要基类对象的任何地方，都可以使用*公有派生类*的对象来替代，也称为**赋值兼容规则**。
   1. 派生类对象可以赋值给基类对象。
   2. 派生类对象可以用来初始化基类引用
   3. 派生类对象的地址可以赋值给基类指针，即派生类的指针可以赋值给基类的指针。

### 5.3 派生类的构造函数和析构函数

`在执行一个派生类的构造函数之前，先执行基类的构造函数。派生对象消亡时，先执行派生类的析构函数，再执行基类的析构函数。`

### 5.4 类之间的关系

**继承关系**：也称为“is a”或者“是”关系。基类集合包含于派生类集合，基类集合中的元素也属于派生类集合，即派生类对象也是一个基类对象。

**组合关系**：也称为“has a”或者“有”关系。即一个类以另一个类的对象作为成员变量。

### 5.5 多层次的派生
`类A派生类B，类B可以再派生类C，类C又能够派生类D，以此类推。这种情况下，类C是类D的直接基类，类A、类B是类D的间接基类。在定义派生类时，只需写直接基类，不需要些间接基类。`

`派生类的成员包括自己定义的成员、直接基类定义的成员及所有间接基类中定义的全部成员。`

`当生成派生对象时，会从最顶（外）层的基类开始逐层往下（里）执行所有基类的构造函数，最后执行派生类自身的构造函数；当派生对象消亡时，会先执行自身的析构函数，然后自底向上依次执行各个基类的析构函数。`

### 5.6 基类与派生类指针的相互转换

派生类对象->基类对象：直接赋值，但不能通过基类指针访问基类中没有而仅在派生类中定义的成员。

基类对象->派生类对象：需强制类型转换后才能赋值，需要保证被转换的基类指针本来就指向一个派生类对象。

## 6 多态与虚函数
### 6.1 多态的基本概念
`不同的对象可以调用相同名称的函数，但可导致完全不同的行为现象`

编译时多态（静态联编）：在编译阶段就能绑定调用语句与调用函数入口地址，即**函数的重载**。

运行时多态（动态联编）：函数调用与代码入口地址的绑定需要在运行时刻才能确定，也称为动态绑定，通过**基类指针**或通过**基类引用**实现多态。

基类指针：基类实例对象；

基类引用：派生类实例对象指针赋给基类指针（把派生类对象当成基类对象）；

虚函数：使用关键字virtual来限定成员函数即为虚函数，只能在类定义中的成员函数声明处使用，不能在类外写成员函数体时使用。

`virtual 返回值类型 函数名(参数表);`

注意：
   1. 全局函数不能声明为虚函数：不属于类，不能被继承。
   2. 构造函数不能声明为虚函数：构造函数调用在对象生成之前，多态发挥作用是在对象生成之后，不统一，且构造函数不能被继承。
   3. 静态成员函数不能声明为虚函数：不归某个对象所独有，没有动态绑定的必要性。
   4. 内联函数不能声明为虚函数：内联函数在编译时被展开，虚函数在运行时才能动态绑定，不统一。
   5. 友元函数不能被声明为虚函数：不属于类的成员函数，不能被继承。
   6. 派生类重写基类的虚函数，要求函数名、参数列表及返回值类型要完全相同。
   7. 派生类重新基类的虚函数，要求保持特性相同。
   8. 不要在构造函数和析构函数中调用虚函数：对象是不完整的，可能出现未定义的行为。
   9. 最好将基类的析构函数声明为虚函数。

### 6.2 多态实例

### 6.3 多态的使用

普通成员函数：在调用其他普通成员函数时，优先调用本类成员函数；在调用虚函数时，若被继承，优先调用派生类虚函数；

注意：
   1. 实现多态时，必须满足：使用基类指针或引用来调用基类中声明的虚函数；
   2. 派生类中继承自基类的虚函数，可以写virtual，也可以不写。不影响派生类中的函数也是虚函数。

### 6.4 虚析构函数
`基类的析构函数为虚函数，其派生类的析构函数也是虚函数。`

声明： `virtual ~类名();`

作用：在对象消亡时实现多态，保证使用基类类型的指针能够调用适当的析构函数针对不同的对象进行清理工作，以避免造成内存泄漏。

### 6.5 纯虚函数和抽象类

纯虚函数：声明在基类中的虚函数，但是没有定义函数体；
   * `virtual 返回值类型 函数名(参数列表) = 0;`

抽象类：包含纯虚函数的类叫做抽象类，其派生类如果**没有给出全部纯虚函数的定义**，则派生类也为抽象类，不能实例化对象。

虚基类：对基类的继承方式前添加关键字`virtual`，则该基类就是虚基类，用于解决基类被多重继承产生的二义性问题。

## 7 输入输出流
### 7.1 流类简介
`C++输入/输出通过调用方法完成，与之相关的类称为“流类”`

常见I/O流类列表：
> 类名||说明|包含文件
> --|--|--|--
> 抽象流基类|ios|流基类|ios
> 输入流类|istream|通用输入流基类和其他输入流基类。cin是该类的对象|istream
> | |ifstream|文件输入流类。用于从文件读取数据|fstream
> 输出流类|ostream|通用输出流基类和其他输出流基类。cout是该类的对象|ostream
> | | ofstream|文件输出流类。用于向文件写入数据|fstream
> 输入输出流类|iostream|通用输入/输出流基类|iostream
> | | fstream|文件输入/输出流类。既能从文件中读取数据，也能向文件中写入数据|fstream

### 7.2 标准流对象
`也称标准流，是为用户提供的常用外设与内存之间通信的通道，对数据进行解释和传输提供必要的数据缓冲等`

iostream标准流对象：
   1. 标准输入流（cin）：用于从键盘输入数据，是流类istream的对象
   2. 标准输出流（cout）：用于向屏幕输出数据，是流类ostream的对象，可以重定向输出到文件
   3. 非缓冲错误输出流（cerr）：不使用缓冲区，直接向显示器输出信息，不能重定向
   4. 缓冲错误输出流（clog）：先被存储到缓冲区，缓冲区满或者刷新时才输出到屏幕

输入输出流重定向：`FILE *freopen(const char*path, const char *mode, FILE *stream)`
   * path：重定向的文件路径
   * mode："W"|"R", 写入或者读取文件
   * stream：stdout|stdin，将cout内容输出至指定文件或者从指定文件获取信息至cin

错误状态字：
> 标识常量|值|含义
> --|--|--|
> goodbit|0x00|流状态正常
> eofbit|0x01|文件结束符
> failbit|0x02|I/O操作失败，数据未丢失，可以恢复
> badbit|0x04|非法操作，数据丢失，不可恢复

判断到达文件尾：`int eof() const`
   * 当文件操作结束时，函数返回1，否则返回0

判断流操作失败：`int fail() const`
   * 失败返回1，否则返回0

判断流操作正常：`int good() const` 或 `int operator void *()`
   * eofbit、failbit和badbit都没有被置位（即均为0）返回1，否则返回0

判断流操作非法：`int bad() const` 或 `int operator void !()`
   * eofbit、failbit和badbit任一被置位（即为1）返回1，否则返回0

查询流状态：`int rdstate() const`

恢复/设置流状态：`void clear(int nStata = 0)`

### 7.3 控制I/O格式

控制方式：一般有**流操纵符**、**设置标志字**和**调用成员函数**

I/O格式：
> 数据类型 | 默认输入格式 | 默认输出格式
> -- | -- | --
> short、int、long(signed、unsigned)|与整型常数相同|一般整型形式，负数前有负号
> float、double、long double|与浮点数相同|浮点或指数格式，取决于哪个更短
> char (singed、unsigned)|第一个非空白字符|单个字符（无引号）
> char *(singed、unsigned)|从第一个空白字符开始到下一个空白字符结束|字符序列（无引号）
> void *|无前缀十六进制数|无前缀十六进制数
> Bool|true或者1识别为true，将false或0识别为false|1或0

流操纵符：也称为格式控制符，对输入/输出数据进行处理。示例：`cout<<流操纵符<<数据<< ...`或`cin>>流操纵符>>变量>>`
> 流操纵符|文件|作用|输入/输出
> --|--|--|--
> endl|iostream|输出一个换行符，并清空流|O
> ends|iostream|输出字符串结束，并清空流|O
> flush|iostream|清空流缓冲区|O
> dec/hex/oct|iostream|以十进制（默认）/十六进制/八进制形式输入或输出整数|I/O
> ws|iostream|提取空白字符|O
> fixed|iomanip|以普通小数形式输出浮点数|O
> scientific|iomanip|以科学计数法形式输出浮点数|O
> left/right|iomanip|左/右（默认）对齐|O
> setbase(int b)|iomanip|指定输出整数时的进制数，b为10、8或16|O
> setw(int w)|iomanip|指定输出宽度为W个字符，或输入时读取W个字符|I/O
> setfill(char c)|iomanip|指定输出宽度下，输出宽度不足时以字符填充，默认空格|O
> setprecision(int n)|iomanip|指定输出浮点数的精度位n(包含整数部分与小数部分)，超过部分四舍五入|O
> boolapha/noboolapha|iomanip|把true或false输出为字符串/0和1（默认）|O
> showbase/noshowbase|iomanip|输出/不输出（默认）表示数值进制的前缀|O
> showpoint/noshowpoint|iomanip|总是/只有当小数部分存在时（默认）显示小数点|O

标志字：带参数的操纵符，与流操纵符不同的是，使用标志字设置的影响是持续的，要设置与原标志字相矛盾的标志字时，得先清除。
   * 设置标志字：`cout<<setiosflags(标志常量名 [|标志常量名2])<<数据`
   * 清除标志字：`cout<<resetiosflags(标志常量名 [|标志常量名2])<<数据`
> 标志常量名|值|含义|输入/输出
> --|--|--|--
> ios::hex|0X0040|转换为十六进制形式|I/O
> ...

### 7.4 调用cout成员函数
`cout中提供成员函数用于控制输出格式，定位和流操纵符相同。`

示例：`cout.方法名(参数)`

方法列表：
> 成员函数|功能|作用相同的流操纵符
> --|--|--
> precision(int n)|设置/获取数据显示精度|setprecision(int n)
> width(int w)|设置/获取显示宽度|setw(int w)
> fill(char c)|设置填充|setfill(char c)
> put(char c)|插入字符|--
> write(const char * c, int n)|插入长度为n的字节序列|--
> setf(long IFloags)|使用参数IFlags置位指定的标志位，返回值为置位前的标志字|setiosflags(IFlags)
> unsetf(long IFloags)|清除参数IFlags指定的标志位，返回值为清除前的标志字|resetiosflags(IFlags)

### 7.5 调用cin成员函数
`cin中提供成员函数用于以不同方式提取输入流中的数据`

示例：`cin.方法名( [参数])`

方法列表：
> 成员函数|功能
> --|--
> get|从输入流中读取一个字符包括空白字符，如果返回值为系统变量EOF，则输入结束
> getline(char *buf, int size [,char d])|从输入流中的当前字符开始读取到size-1个字符或读到d为止到缓冲区buf
> eof|判断输入流是否已经结束
> ignore(int n, char d)|跳过输入流中的n个字符或者跳过d以前的所有字符
> peek|返回输入流中当前字符的拷贝

## 8 文件操作
### 8.1 文件基本概念和文件流类

文件流类：
   * 文件读取：ifstream
   * 文件写入：ofstream
   * 文件读写：fstream

### 8.2 打开和关闭文件

打开文件：建立连接，并指明文件格式和使用方式；打开失败时，对象为空
* 建立流对象，然后调用open：`类名 流对象名; 流对象名.open(文件名, 模式标记)`
* 调用流类带参构造函数：`类名 流对象名(文件名, 模式标记)`

模式标记|适用对象|作用
--|--|--|
ios::in|ifstream<br>fstream|以读方式打开。若文件不存在则报错
ios::out|ofstream<br>fstream|以写方式打开。若文件不存在则新建；若文件已存在则清空
ios::app|ofstream|以追加方式打开文件，用于文件尾部添加数据。若文件不存在则新建
ios::trunc|ofstream|删除文件现有内容，单独使用时与ios::out相同
ios::binary|ifstream<br>ofstream<br>fstream|以二进制方式打开（默认）
ios::in\|ios::out|ofstream<br>fstream|打开已有的文件，内容保持，可以写入。若文件不存在则报错

关闭文件：发出关闭文件命令后，系统会将缓冲区的数据完整地写入文件，同时添加文件结束标记，切断流对象与外部文件的连接（流对象可再次用于操作别的文件）
* 调用close：`流对象名.close();`

### 8.3 文件读写操作

文本文件：以ASCII码形式保存，占用空间较大，但使用方便；在进行数据写入/读取时需要额外进行内存和外存的数据格式转换。
* 写入：每次写入时建议以空格分隔内容。
   * 流插入运算符：`输出对象名<<"内容"`

* 读取：每次读取到空格时返回结果。
   * 流提取运算符：`输入对象名>>变量`

二进制文件：以二进制形式存放，其存储格式与内存格式一致；二进制数据流写入/读取时不需要进行数据格式转换，便于高速处理。
* 写入：
   * write：`输出对象名.write((char *) & 变量, int sizeof(变量))`
* 读取：遇到文件结束符时，返回系统常量EOF
   * read：`输入对象名.read((char *) & 变量, int sizeof(变量))`

通用文件操作：
* 写入：
   * put：`输出对象名.put(char c)`
* 读取：
   * get：`输入对象名.get(char c)`

### 8.4 随机访问文件

顺序文件：只能进行顺序存取操作的文件。如键盘、显示器和保存在磁带上的文件

随机文件：可以在文件任意位置（也可以是顺序）进行存取操作的文件。如磁盘文件

流指针：由系统控制，会随着对流的操作在字节流中移动。

文件位置指针：对文件的操作生成的流指针叫文件位置指针。文件打开时，位置指针指向文件的第一个字节（如果以ios::ate方式打开，则指向文件末尾），每完成一次读/写操作后，位置指针自动移动到下一个读/写分量的起始位置。
   * 移动读指针：
      * 移动至指定位置：`istream & seekg(long pos)`
      * 移动相对位置：`istream & seekg(long offset, ios::seek_dir dir)`
         > ios::seek_dir：ios::beg 以流开始位置为基准，向后移offset；ios::cur 以流指针当前位置为基准，向后移offset；ios::end 以流结尾位置为基准，向前移offset
   * 返回读指针：`long tellg()`
   * 移动写指针:
      * 移动至指定位置：`ostream & seekp(long pos)`
      * 移动相对位置：`ostream & seekp(long offset, ios::seek_dir dir)`
   * 返回写指针：`long tellp()`
