# 计算机系统结构
## 1. 概论
### 1.1 计算机系统的层次结构

机器：能存储和执行响应语言程序的算法和数据结构的几何体

> 机器|语言类别|功能
> :-:|:-|:-
> 应用语言机器 M5|应用语言|应用语言程序经应用程序包翻译成高级语言程序
> 高级语言机器 M4|高级语言|高级语言程序经编译程序翻译成汇编语言程序（或是机器语言程序）
> 汇编语言机器 M3|汇编语言|汇编语言程序经汇编程序翻译成机器语言程序
> 操作系统机器 M2|作业控制语句|一般用机器语言程序解释作业控制语句
> 传统语言机器 M1|机器指令系统（二进制）|用微指令程序解释机器指令
> 微程序机器 M0|微指令系统|微指令由硬件直接执行

**固件：** 具有软件功能的硬件。如：BIOS。

**翻译：** 用转换程序将高一级机器级上的程序**整个翻译**成低一级机器级上等效的程序。

**解释：** 在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级机器级语言程序中的每条语句或指令**逐条解释**来实现的技术。

### 1.2 计算机系统结构、计算机组成和计算机实现
#### 1.2.1 计算机系统结构的定义和内涵

定义：系统结构是对计算机系统中各级界面（不同机器语言程序员所看到的计算机属性是不同的，它就是计算机系统不同层次的界面）的定义及其上下功能的分配。

内涵：计算机系统结构研究的是软、硬件之间的功能分配以及对传统机器级界面的确定。

#### 1.2.2 计算机组成与计算机实现的定义和内涵

计算机组成：指计算机系统结构的逻辑实现，着眼于机器级内部各事件的排序方式与控制机构、各部件的功能与各部件间的联系。

计算机实现：指计算机组成的物理实现，着眼于**器件技术**与微组装技术。

区别：
* 指令：取指令、指令操作码译码、取址、运算等属于计算机组成；实现指令功能的具体电路设计、器件的设计及装配技术属于计算机的实现。
* 主存：器件的性能需求属于计算机组成；器件的选定、微组装技术属于计算机实现。

#### 1.2.3 计算机系统结构、组成和实现的相互关系和影响

* 结构不同会使能采用的组成技术不同
* 组成也会影响结构
* 组成向上决定于结构，向下受限于实现。

### 1.3 计算机系统的软、硬件取舍及定量设计原理
#### 1.3.1 软、硬件取舍的基本原则
`从原理上将，软件的功能可以用硬件或固件来完成，硬件的功能也可以用软件模拟完成；提高硬件功能的比例可提高解题速度，减少程序所需的存储空间，但会增加硬件成本，降低硬件利用率和计算机系统的灵活性`

* 原则1： 在现有的（逻辑和存储）器件条件下，系统要有高性能价格比

* 原则2： 要考虑到准备采用和可能采用的组成技术，使之尽可能的不要过多或不合理的限制各种组成、实现技术的采用

* 原则3： 不能仅从“硬”的角度考虑如何便于应用组成技术和发挥器件技术，还应从“软”的角度把如何为编译、操作系统的实现和高级语言程序提供更多、更好的硬件支持放在首位

#### 1.3.2 计算机系统的定量设计原理

* 哈夫曼（Huffman）压缩原理：尽可能加速处理高概率事件比加速处理低概率事件对性能提高显著。

* Amdahl 定律：用于确定对系统中性能瓶颈部件改进后的性能与未改进时的比值。
    ```
    Sp: 加速比
    Told：未改进时程序执行时间
    Tnew：改进后程序执行时间
    Fnew：可改进比(0 <= Fnew <= 1)
    Rnew：加速比(Rnew > 1)
    Sp = Told / Tnew = 1 / ((1 - Fnew) + Fnew / Rnew)
    ```
* 程序访问的局部性定律：包括了时间上和空间上两个局部性。
    * 时间上的局部性：现在正使用的信息可能不及还要用
    * 空间上的局部性：将来要使用的信息可能与正在使用的相邻，这是因为指令通常是顺序存放、顺序执行的

#### 1.3.3 计算机系统设计的主要任务和方法

主要任务：包括系统结构、组成和实现的设计
1. 要弄清楚其应用领域，专用还是通用。
2. 要弄清软件兼容是放在哪级层次，高级语言级还是传统机器语言级。
3. 要弄清对操作系统有何种要求，何种存储系统设计。
4. 要如何保证有高的标准化程度

设计方法：有由上往下、由下往上、从中间开始3种不同的设计方法
1. 由上往下：先考虑如何满足应用要求，定好面向应用的那个虚拟机器级的工作环境。
2. 由下往上：先不管应用要求，只根据目前能用的器件，参照、吸收已有的机器特点，将微程序机器级或传统机器级研制出来。
3. 从中间开始：这是通用机一般采用的方法，它可以克服以上两种方法中软、硬件分离的致命缺点。在传统机器语言机器级与操作系统语言机器级之间进行合理的软、硬件分配。

### 1.4 软件、应用、器件的发展对系统结构的影响
#### 1.4.1 软件发展对系统结构的影响

软件的可移植性：软件不修改或只经少量修改就可以由一台机器移到另一台机器上运行。

实现软件移植的技术：
1. **统一高级语言**：统一出一种可以满足各种应用需要的高级语言，但不同用途要求语言的语义、语法不同，人们对语言的基本结构看法也不一致，也受习惯阻力。`

2. **采用系列机**：在一定范围内不同型号的机器之间统一汇编语言，一般应做到向上兼容。
3. **模拟和仿真**
    * 模拟：宿主机使用主存中的*机器语言程序*解释虚拟机指令。
    * 仿真：宿主机使用存储于控制存储器中的*微程序语言程序*解释虚拟机指令。
    * 选择：频繁使用且易于仿真的机器指令宜用房子，以提高速度；很少使用、难以仿真的指令及I/O操作宜用模拟；即使两种机器系统差别不大，往往也用模拟来完成机器间的映射。

#### 1.4.2 应用的发展对系统结构的影响
`从用户角度来讲，总希望机器的应用范围越宽越好。就应用而言，程序可移植、高性能价格比、便于使用这些都是基本要求；对于厂商来讲，机器型号减少，同一型号的机器适应面扩大，使每种型号的机器产量大`

#### 1.4.3 器件的发展对系统结构的影响
`器件的发展加速了结构的“下移”，大型机的各种数据表示、指令系统、操作系统很快出现在小、微型机上。器件的发展为多CPU分布处理、智能终端、智能机的发展提供了基础`

非用户片：也称通用片，其功能是由器件厂家生产时固定的，用户只能使用，不能改变器件内部功能。

现场片：用户可根据需要改变器件内部功能

用户片：按用户要求生产的高集成度器件

### 1.5 系统结构中的并行性开发及计算机系统的分类
#### 1.5.1 并行性的概念与开发

并行性：包含同时性和并发性二重含义。
* 同时性：指两个或多个时间在同一时刻发生。
* 并发性：指两个或多个时间在同一时间间隔内发生

并行性等级划分（由低到高）：
* 从计算机系统执行程度的角度：指令内部、指令之间、任务或进程之间、作业或程序之间
* 从计算机系统处理数据的角度：位串字串、位并字串、位片串字并、全并行
* 从计算机信息加工各步骤来看：存储器操作并行（相联处理机）、处理器操作步骤并行（流水线处理机）、处理器操作并行（阵列处理机）、指令任务作业并行（多处理机）

并行性开发途径：
* 时间重叠：让多个处理器在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分
* 资源重复：通过重复设置硬件资源来提高可靠性或性能
* 资源共享：用软件的方法，让多个用户安一定时间顺序轮流使用同一套资源来提高资源利用率，如多道程序的分时系统

并行性的发展：主要表现为算术运算的位并行及运算输入/输出操作的并行

#### 1.5.2 计算机系统的分类

弗林分类法：按指令流和数据流的多倍性对计算机系统分类。
* 单指令流单数据流：传统的单处理机
* 单指令流多数据流：相联处理机和阵列处理机
* 多指令流单数据流：脉动阵列流水机（不多见）
* 多指令流多数据流：紧密耦合、松散耦合的多机系统

## 2. 数据表示、寻址方式与指令系统
### 2.1 数据表示
#### 2.1.1 数据表示与数据结构

数据表示：指能由计算机硬件识别的和引用的数据类型，表现在有对这种类型的数据进行操作的指令和运算部件。

数据结构：指各种数据元素或信息单元之间的关系。

关系：数据结构要通过软件映像，变换成计算机所具有的数据表示。

#### 2.1.2 高级数据表示

* 自定义数据表示：包括标志符数据表示和描述符。
    * 标志符数据表示：由编译程序建立，在数据字中留有一定位指明其具体是数值、控制信息、地址还是指令字。
        * 优点：
            1. 简化了指令系统和程序设计：指令通用于多种数据类型的处理。
            2. 简化了编译程序：比如遇到"+"算子时，不用具体查询需要用浮加还是整加。
            3. 便于实现一致性校验：操作数定义错误（如乘法指令的操作数是字符串）可由硬件直接检测出来。
            4. 能由硬件自动变换数据类型：加法指令的一个操作数是整数，一个是浮点数，硬件自动转换成浮点数相加
            5. 支持数据库系统实现与数据类型无关的要求
            6. 为调试和应用软件开发提供了支持
        * 缺点：
            1. 每个数据字因增设标志符，会增加所占主存空间。
            2. 每次执行需要确定数据属性及判断操作数之间的相容性，单条指令的执行速度会下降。

    * 数据描述符：数据描述符以`101`开始，含各种标志位、长度信息，以及地址。指向以`000`开始的数据字，二者分开存放。

* 向量、数组数据表示
* 堆栈数据表示

#### 2.1.3 引入数据表示的原则

1. 看系统效率是否提高，包括实现时间和存储空间是否有显著减少。
2. 看引入这种数据表示后，其通用性和利用率是否提高。

#### 2.1.4 浮点数尾数基值大小和下溢处理方法的选择

基值选择：数学中实数在数轴上是连续分布的，但由于计算机字长有限，浮点数只能表示出数轴上分散于正、负两个区间上的部分离散值。
```ts
对于规格化正尾数：
    最小值 = 进制数 ^ (-1)
    最大值 = 1 - 1 / (进制数 ^ (-位数)))
```
* 可表示数范围：进制数增大，可表示最大值增大，可表示最小值减小
* 可表示数个数：进制数增大，可表示个数增多
* 数在数轴上的分布：进制数增大，数在数轴上的分布越稀
* 可表示精度：进制数增大，可表示精度降低
* 运算中的精度损失：进制数增大，尾数溢出右移的机会少，运算中的精度损失就越小
* 运算速度：进制数增大，对于尾数溢出右移及规格化左移次数减少，运算速度提高。





