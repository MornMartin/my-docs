# 计算机系统结构
## 1. 概论
### 1.1 计算机系统的层次结构

机器：能存储和执行响应语言程序的算法和数据结构的几何体

> 机器|语言类别|功能
> :-:|:-|:-
> 应用语言机器 M5|应用语言|应用语言程序经应用程序包翻译成高级语言程序
> 高级语言机器 M4|高级语言|高级语言程序经编译程序翻译成汇编语言程序（或是机器语言程序）
> 汇编语言机器 M3|汇编语言|汇编语言程序经汇编程序翻译成机器语言程序
> 操作系统机器 M2|作业控制语句|一般用机器语言程序解释作业控制语句
> 传统语言机器 M1|机器指令系统（二进制）|用微指令程序解释机器指令
> 微程序机器 M0|微指令系统|微指令由硬件直接执行

**固件：** 具有软件功能的硬件。如：BIOS。

**翻译：** 用转换程序将高一级机器级上的程序**整个翻译**成低一级机器级上等效的程序。

**解释：** 在低级机器级上用它的一串语句或指令来仿真高级机器级上的一条语句或指令的功能，是通过对高级机器级语言程序中的每条语句或指令**逐条解释**来实现的技术。

### 1.2 计算机系统结构、计算机组成和计算机实现
#### 1.2.1 计算机系统结构的定义和内涵

定义：系统结构是对计算机系统中各级界面（不同机器语言程序员所看到的计算机属性是不同的，它就是计算机系统不同层次的界面）的定义及其上下功能的分配。

内涵：计算机系统结构研究的是软、硬件之间的功能分配以及对传统机器级界面的确定。

#### 1.2.2 计算机组成与计算机实现的定义和内涵

计算机组成：指计算机系统结构的逻辑实现，着眼于机器级内部各事件的排序方式与控制机构、各部件的功能与各部件间的联系。

计算机实现：指计算机组成的物理实现，着眼于**器件技术**与微组装技术。

区别：
* 指令：取指令、指令操作码译码、取址、运算等属于计算机组成；实现指令功能的具体电路设计、器件的设计及装配技术属于计算机的实现。
* 主存：器件的性能需求属于计算机组成；器件的选定、微组装技术属于计算机实现。

#### 1.2.3 计算机系统结构、组成和实现的相互关系和影响

* 结构不同会使能采用的组成技术不同
* 组成也会影响结构
* 组成向上决定于结构，向下受限于实现。

### 1.3 计算机系统的软、硬件取舍及定量设计原理
#### 1.3.1 软、硬件取舍的基本原则
`从原理上将，软件的功能可以用硬件或固件来完成，硬件的功能也可以用软件模拟完成；提高硬件功能的比例可提高解题速度，减少程序所需的存储空间，但会增加硬件成本，降低硬件利用率和计算机系统的灵活性`

* 原则1： 在现有的（逻辑和存储）器件条件下，系统要有高性能价格比

* 原则2： 要考虑到准备采用和可能采用的组成技术，使之尽可能的不要过多或不合理的限制各种组成、实现技术的采用

* 原则3： 不能仅从“硬”的角度考虑如何便于应用组成技术和发挥器件技术，还应从“软”的角度把如何为编译、操作系统的实现和高级语言程序提供更多、更好的硬件支持放在首位

#### 1.3.2 计算机系统的定量设计原理

* 哈夫曼（Huffman）压缩原理：尽可能加速处理高概率事件比加速处理低概率事件对性能提高显著。

* Amdahl 定律：用于确定对系统中性能瓶颈部件改进后的性能与未改进时的比值。
    ```
    Sp: 加速比
    Told：未改进时程序执行时间
    Tnew：改进后程序执行时间
    Fnew：可改进比(0 <= Fnew <= 1)
    Rnew：加速比(Rnew > 1)
    Sp = Told / Tnew = 1 / ((1 - Fnew) + Fnew / Rnew)
    ```
* 程序访问的局部性定律：包括了时间上和空间上两个局部性。
    * 时间上的局部性：现在正使用的信息可能不及还要用
    * 空间上的局部性：将来要使用的信息可能与正在使用的相邻，这是因为指令通常是顺序存放、顺序执行的

#### 1.3.3 计算机系统设计的主要任务和方法

主要任务：包括系统结构、组成和实现的设计
1. 要弄清楚其应用领域，专用还是通用。
2. 要弄清软件兼容是放在哪级层次，高级语言级还是传统机器语言级。
3. 要弄清对操作系统有何种要求，何种存储系统设计。
4. 要如何保证有高的标准化程度

设计方法：有由上往下、由下往上、从中间开始3种不同的设计方法
1. 由上往下：先考虑如何满足应用要求，定好面向应用的那个虚拟机器级的工作环境。
2. 由下往上：先不管应用要求，只根据目前能用的器件，参照、吸收已有的机器特点，将微程序机器级或传统机器级研制出来。
3. 从中间开始：这是通用机一般采用的方法，它可以克服以上两种方法中软、硬件分离的致命缺点。在传统机器语言机器级与操作系统语言机器级之间进行合理的软、硬件分配。

### 1.4 软件、应用、器件的发展对系统结构的影响
#### 1.4.1 软件发展对系统结构的影响

软件的可移植性：软件不修改或只经少量修改就可以由一台机器移到另一台机器上运行。

实现软件移植的技术：
1. **统一高级语言**：统一出一种可以满足各种应用需要的高级语言，但不同用途要求语言的语义、语法不同，人们对语言的基本结构看法也不一致，也受习惯阻力。`

2. **采用系列机**：在一定范围内不同型号的机器之间统一汇编语言，一般应做到向上兼容。
3. **模拟和仿真**
    * 模拟：宿主机使用主存中的*机器语言程序*解释虚拟机指令。
    * 仿真：宿主机使用存储于控制存储器中的*微程序语言程序*解释虚拟机指令。
    > 频繁使用且易于仿真的机器指令宜用仿真，以提高速度；很少使用、难以仿真的指令及I/O操作宜用模拟；即使两种机器系统差别不大，往往也用模拟来完成机器间的映射。

#### 1.4.2 应用的发展对系统结构的影响
`从用户角度来讲，总希望机器的应用范围越宽越好。就应用而言，程序可移植、高性能价格比、便于使用这些都是基本要求；对于厂商来讲，机器型号减少，同一型号的机器适应面扩大，使每种型号的机器产量大`

#### 1.4.3 器件的发展对系统结构的影响
`器件的发展加速了结构的“下移”，大型机的各种数据表示、指令系统、操作系统很快出现在小、微型机上。器件的发展为多CPU分布处理、智能终端、智能机的发展提供了基础`

非用户片：也称通用片，其功能是由器件厂家生产时固定的，用户只能使用，不能改变器件内部功能。

现场片：用户可根据需要改变器件内部功能

用户片：按用户要求生产的高集成度器件

### 1.5 系统结构中的并行性开发及计算机系统的分类
#### 1.5.1 并行性的概念与开发

并行性：包含同时性和并发性二重含义。
* 同时性：指两个或多个时间在同一时刻发生。
* 并发性：指两个或多个时间在同一时间间隔内发生

并行性等级划分（由低到高）：
* 从计算机系统执行程度的角度：指令内部、指令之间、任务或进程之间、作业或程序之间
* 从计算机系统处理数据的角度：位串字串、位并字串、位片串字并、全并行
* 从计算机信息加工各步骤来看：存储器操作并行（相联处理机）、处理器操作步骤并行（流水线处理机）、处理器操作并行（阵列处理机）、指令任务作业并行（多处理机）

并行性开发途径：
* 时间重叠：让多个处理器在时间上相互错开，轮流重叠地使用同一套硬件设备的各个部分
* 资源重复：通过重复设置硬件资源来提高可靠性或性能
* 资源共享：用软件的方法，让多个用户安一定时间顺序轮流使用同一套资源来提高资源利用率，如多道程序的分时系统

并行性的发展：主要表现为算术运算的位并行及运算输入/输出操作的并行

#### 1.5.2 计算机系统的分类

弗林分类法：按指令流和数据流的多倍性对计算机系统分类。
* 单指令流单数据流：传统的单处理机
* 单指令流多数据流：相联处理机和阵列处理机
* 多指令流单数据流：脉动阵列流水机（不多见）
* 多指令流多数据流：紧密耦合、松散耦合的多机系统

## 2. 数据表示、寻址方式与指令系统
### 2.1 数据表示
#### 2.1.1 数据表示与数据结构

数据表示：指能由计算机硬件识别的和引用的数据类型，表现在有对这种类型的数据进行操作的指令和运算部件。

数据结构：指各种数据元素或信息单元之间的关系。

关系：数据结构要通过软件映像，变换成计算机所具有的数据表示。

#### 2.1.2 高级数据表示

* 自定义数据表示：包括标志符数据表示和描述符。
    * 标志符数据表示：由编译程序建立，在数据字中留有一定位指明其具体是数值、控制信息、地址还是指令字。
        * 优点：
            1. 简化了指令系统和程序设计：指令通用于多种数据类型的处理。
            2. 简化了编译程序：比如遇到"+"算子时，不用具体查询需要用浮加还是整加。
            3. 便于实现一致性校验：操作数定义错误（如乘法指令的操作数是字符串）可由硬件直接检测出来。
            4. 能由硬件自动变换数据类型：加法指令的一个操作数是整数，一个是浮点数，硬件自动转换成浮点数相加
            5. 支持数据库系统实现与数据类型无关的要求
            6. 为调试和应用软件开发提供了支持
        * 缺点：
            1. 每个数据字因增设标志符，会增加所占主存空间。
            2. 每次执行需要确定数据属性及判断操作数之间的相容性，单条指令的执行速度会下降。

    * 数据描述符：数据描述符以`101`开始，含各种标志位、长度信息，以及地址。指向以`000`开始的数据字，二者分开存放。

* 向量、数组数据表示
* 堆栈数据表示

#### 2.1.3 引入数据表示的原则

1. 看系统效率是否提高，包括实现时间和存储空间是否有显著减少。
2. 看引入这种数据表示后，其通用性和利用率是否提高。

#### 2.1.4 浮点数尾数基值大小和下溢处理方法的选择

基值选择：数学中实数在数轴上是连续分布的，但由于计算机字长有限，浮点数只能表示出数轴上分散于正、负两个区间上的部分离散值。
```ts
对于规格化正尾数：
    最小值 = 进制数 ^ (-1)
    最大值 = 1 - 1 / (进制数 ^ (-位数)))
```
* 可表示数范围：进制数增大，可表示最大值增大，可表示最小值减小
* 可表示数个数：进制数增大，可表示个数增多
* 数在数轴上的分布：进制数增大，数在数轴上的分布越稀
* 可表示精度：进制数增大，可表示精度降低
* 运算中的精度损失：进制数增大，尾数溢出右移的机会少，运算中的精度损失就越小
* 运算速度：进制数增大，对于尾数溢出右移及规格化左移次数减少，运算速度提高。

下溢处理：减少运算中的精度损失关键是要处理好运算中尾数超出字长部分，使之精度损失最小。
1. 截断法：将尾数超出计算机字长部分截去。实现最简单，最大误差大，平均误差无法调节。
2. 舍入法：在计算机运算的规定字长之外增设一位附加位，存放溢出部分的最高位，每当进行尾数下溢处理时，将附加位加一。实现简单，最大误差小，平均误差接近零，但速度慢。
3. 恒置"1"法：将计算机运算规定的字长最低位恒置为"1"。实现最简单，平均误差趋近于零，但最大误差最大。
4. 查表舍入法：用ROM或PLA存放下溢处理表。速度快，平均误差可调节到零，是最好的方法，但需要的硬件量大。

### 2.2 寻址方式
`指令按什么方式寻址（或访问）到所需的操作数或信息`
#### 2.2.1 寻址方式的三种面向
`多数计算机都将主存、寄存器、堆栈分类编址，分别有面向主存、面向寄存器和面向堆栈的寻址方式。`
#### 2.2.2 寻址方式在指令中指明
`一种是占用操作码中的某些位来指明，另一种是在地址码部分专门设置寻址方式位字段指明`
#### 2.2.3 程序在主存中的定位技术
`逻辑地址时程序员编程用的地址，主存物理地址是程序员在主存中的实际地址。`

1. 静态再定位：在目的程序装入主存时，由装入程序用软件方法把目的程序用到的逻辑地址变换成物理地址，程序执行时，物理地址不再改变。

2. 动态再定位：通过增加相应的基址寄存器和地址加法器硬件，在程序不做变换直接装入主存的同时，将装入主存的起始地址存入对应该道程序使用的基址寄存器中。程序执行时，只要通过地址加法器将逻辑地址加上基址寄存器的程序基址形成物理地址。

3. 虚实地址映像表：通过增设地址映像表机构，将程序分割成若干段装入主存，同时用相应的映射表指明其在主存中的起始地址。程序执行时，查询映像表将逻辑地址变换成物理地址。

#### 2.2.4 物理主存中信息的存储分布
`1字节=8位，1字=4字节，双字=8字节`

`一般主存信息宽度64位，即一个存储周期可以访问8个字节。为了使任何时候所需的信息都只用一个存储周期访问到，要求信息在主存中存放的地址必须是该信息宽度的整数倍。`

### 2.3 指令系统的设计和优化
#### 2.3.1 指令系统设计的基本原则
`指令系统是程序设计者看计算机的主要属性，是软、硬件的主要界面。`

编译程序设计者要求：
1. 规整性：对相似的操作做相同的规定。
2. 对称性：有A-B->A就得有A-B->B。
3. 独立性和全能性：实现同一种功能的选择限定只有一个。
4. 正交性：指令中各个不同含义的字段，在编码时应互不相干，相互独立。
5. 可组合性：让指令系统中所有的操作对各种寻址方式和数据类型都能使用。
6. 可扩充性：留一定的冗余操作码，以便扩充新指令。

系统结构设计者要求：

7. 指令码密度适中：高密度指令指的是强功能复合指令。高密度指令数过多，能减少程序长度，减少程序访存次数，但会使指令系统过于复杂，硬件实现及其不便。
8. 兼容性：为保证软件向后兼容，只能新增指令，不能修改和删除。
9. 适应性：当工艺技术发展变化时，指令系统仍可以方便地用硬件来实现。

#### 2.3.2 指令操作码的优化
`指令是由操作码和地址码组成。`

优化：主要是为了缩短指令字长，减少程序总位数及增加指令字能表示的操作信息和地址信息。

哈夫曼压缩：当各种概率事件发生的概率不均等时，对发生概率最高的事件使用最短的位数来表示。

哈夫曼树：
>```mermaid
>graph RL
>A(1.0)--0-->B(指令A-0.6)
>A --1-->C(非指令A-0.4)
>C --0-->D(指令B-0.1)
>C --1-->E(非指令B-0.3)
>E --0-->F(指令C-0.1)
>E --1-->G(非指令C-0.2)
>G --0-->H(指令D-0.1)
>G --1-->I(指令E-0.1)
>```

> |||||||
> :-:|:-:|:-:|:-:|:-:|:-:|
> 指令|A|B|C|D|E|
> 编码|0|10|110|1110|1111

信息源熵：信息源所含的平均信息量
```ts
H = [指令1频度 * 指令1码长, 指令2频度 * 指令2码长, ...].reduce((a, b) => a + b);
```
信息冗余：
```ts
信息冗余 = (实际平均码长 - 信息源熵)/实际平均码长
```

拓展操作码编码：界于定长二进制编码和完全哈夫曼编码之间的一种编码方式，操作码不是定长的，但只有有限几种码长，便于译码。

#### 2.3.4 指令字的格式化

1. 采用拓展操作码，并根据指令频道分布状况选择合适的编码方式，以缩短操作码的平均长度。
2. 采用诸如基址、变址、相对、寄存器、寄存器间接、段式存放、隐式指明等多种寻址方式，以缩短地址码长度。
3. 采用1、2、3等多种地址制，以增强指令功能。
4. 在同种地址制内再采用多种地址形式，如寄存器-寄存器、寄存器-主存、主存-主存等，让每种地址字段可以有多种长度，且让长操作码与短地址码进行组配。
5. 在维持指令字在寄存器中按整数边界存储的前提下，使用多种不同的指令字长度。

### 2.4 指令系统的发展和改进
#### 2.4.1 两种途径和方向

* CISC：如何进一步增强原有指令的功能以及设置更为复杂的新指令以取代原先由软件子程序完成的功能，实现软件功能硬化。
* RISC：如何通过减少指令种数和简化指令功能来降低硬件设计的复杂度，提高指令的执行速度。

#### 2.4.2 按CISC方向发展和改进指令系统
1. 面向目标程序的优化实现改进
    * 对高频指令，可增强其功能，加快其执行速度，缩短其指令长度
    * 增设强功能复合指令来取代原先由常用宏指令或子程序实现的功能，由微程序解释实现。
2. 面向高级语言的优化实现改进：**缩短高级语言与机器语言的语义差距**
    * 对高频语句增设语义差距小的新指令
    * 增强系统的规整性，尽量减少例外或特殊的情况和用法
    * 让计算机具有面向各种高级语言的多种指令系统、多种系统结构的面向问题动态自寻优。
    * 发展高级语言计算机
3. 面向操作系统的优化实现改进
    * 通过对操作系统中常用的指令和指令串的使用频度进行统计分析来改进
    * 考虑增设专用于操作系统的新指令
    * 把操作系统中频繁使用的，对速度影响大的机构型软件子程序固化
    * 发展有操作系统专门处理机的分布系统处理结构

#### 2.4.3 按RISC方向发展和改进指令系统

CISC问题：机器结构、指令系统庞大且复杂。

设计RISC基本原则：
1. 确定指令系统时，只选择使用频度很高的指令，增加少量能有效支持操作系统、高级语言实现的指令，一般不超过100条
2. 减少指令系统寻址方式种类，一般不超过2种。简化指令格式，限制在2种，并让全部指令都是相同长度
3. 让所有指令都在一个机器周期内完成
4. 扩大通用寄存器书，一般不超过32个，只有存、取指令访存，其他指令一律只对寄存器操作
5. 为提高执行速度，大多数指令都用硬联控制实现，少数指令采用微程序实现
6. 精简指令、优化设计编译程序

设计RISC基本技术：
1. 按设计RISC的一般原则来设计
2. 逻辑实现采用硬联和微程序相结合
3. 在CPU中设置大量工作寄存器并采用重叠寄存器窗口
4. 指令用流水和延迟转移
5. 采用高速缓冲存储器Cache
6. 优化编译系统

RISC优点：
1. 简化指令系统设计
2. 提高计算机的执行速度和效率
3. 降低设计成本，提高系统可靠性
4. 可直接支持高级语言的实现，简化编译程序的设计

RISC问题：
1. 由于指令少，某些复杂功能现在要用多条指令才能完成，增加了机器语言程序的长度，占用存储空间多
2. 对浮点运算的执行和虚拟存储器的支持不足
3. RISC的计算机编译程序比CISD的难写
